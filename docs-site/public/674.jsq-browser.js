"use strict";(this.webpackChunkJSQ=this.webpackChunkJSQ||[]).push([[674],{674:(n,e,t)=>{t.d(e,{createVMLodashCode:()=>r});var a=t(201);function r(){return`\n${a.v}\n\n// Simplified Lodash class for VM environment\nif (typeof Lodash === 'undefined') {\n  globalThis.Lodash = class Lodash {\n    constructor(value) {\n      this._value = value;\n      // Don't set this.value here - it conflicts with the value() method\n      this.__isLodash = true;\n    }\n    \n    [Symbol.iterator]() {\n      if (this._value === null || this._value === undefined) {\n        return [][Symbol.iterator]();\n      }\n      if (Array.isArray(this._value) || typeof this._value === 'string') {\n        return this._value[Symbol.iterator]();\n      }\n      if (this._value && typeof this._value === 'object') {\n        return Object.entries(this._value)[Symbol.iterator]();\n      }\n      return [][Symbol.iterator]();\n    }\n    \n    toJSON() {\n      return this._value;\n    }\n    \n    valueOf() {\n      return this._value;\n    }\n    \n    toString() {\n      if (this._value === null) return 'null';\n      if (this._value === undefined) return 'undefined';\n      return String(this._value);\n    }\n    \n    [Symbol.toPrimitive](hint) {\n      if (hint === 'string') {\n        return this.toString();\n      }\n      return this._value;\n    }\n  };\n}\n\n// Apply all methods to Lodash prototype\nif (typeof globalThis.lodashMethods !== 'undefined' && typeof globalThis.Lodash !== 'undefined') {\n  Object.entries(globalThis.lodashMethods).forEach(([name, fn]) => {\n    globalThis.Lodash.prototype[name] = fn;\n  });\n}\n\n// Create _ function first before using it in the setup\nglobalThis.createLodash = function(value) {\n  return new globalThis.Lodash(value);\n};\n\n// Set up _ for direct use (always override)\n// Create _ as a function that wraps values\nglobalThis._ = function(value) {\n  if (arguments.length === 0) {\n    // If called without arguments and data exists AND is not null, use data\n    if (typeof globalThis.data !== 'undefined' && globalThis.data !== null) {\n      return new globalThis.Lodash(globalThis.data);\n    }\n    // Otherwise return undefined\n    return undefined;\n  }\n  return new globalThis.Lodash(value);\n};\n\n// Add static methods to _ (like _.chunk, _.filter, etc)\nObject.entries(globalThis.lodashMethods).forEach(([name, fn]) => {\n  globalThis._[name] = function(...args) {\n    // Special handling for pure utility functions that don't operate on data\n    if (name === 'range') {\n      // _.range(end) or _.range(start, end, step)\n      if (args.length === 0) return [];\n      if (args.length === 1) {\n        // _.range(5) -> [0, 1, 2, 3, 4]\n        const end = Number(args[0]) || 0;\n        const result = [];\n        for (let i = 0; i < end; i++) {\n          result.push(i);\n        }\n        return result;\n      } else {\n        // _.range(2, 8) or _.range(2, 8, 2)\n        const start = Number(args[0]) || 0;\n        const end = Number(args[1]) || 0;\n        const step = Number(args[2]) || 1;\n        const result = [];\n        if (step > 0) {\n          for (let i = start; i < end; i += step) {\n            result.push(i);\n          }\n        } else {\n          for (let i = start; i > end; i += step) {\n            result.push(i);\n          }\n        }\n        return result;\n      }\n    }\n    \n    if (name === 'times') {\n      // _.times(n, iteratee)\n      if (args.length === 0) return [];\n      const n = Number(args[0]) || 0;\n      const iteratee = args[1] || ((i) => i);\n      const results = [];\n      for (let i = 0; i < n; i++) {\n        results.push(iteratee(i));\n      }\n      return results;\n    }\n    \n    // For static methods, wrap the first argument\n    if (args.length > 0) {\n      let dataToWrap = args[0];\n      \n      // If the first argument is a SmartDollar instance, unwrap it\n      if (dataToWrap && typeof dataToWrap === 'object' && dataToWrap.__isSmartDollar) {\n        dataToWrap = dataToWrap.valueOf();\n      }\n      \n      const wrapped = new globalThis.Lodash(dataToWrap);\n      const result = wrapped[name](...args.slice(1));\n      // If result is a Lodash instance, unwrap it for static methods\n      if (result && typeof result === 'object' && result.__isLodash) {\n        return result._value;\n      }\n      return result;\n    }\n    // For methods that don't need arguments\n    return fn.call({_value: undefined, constructor: globalThis.Lodash});\n  };\n});\n`}}}]);