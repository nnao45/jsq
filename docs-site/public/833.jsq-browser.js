"use strict";(this.webpackChunkJSQ=this.webpackChunkJSQ||[]).push([[833],{833:(e,r,n)=>{n.r(r),n.d(r,{VMSandboxQuickJS:()=>a});var t=n(867);class a{constructor(e,r={}){this.appContext=e,this.config={memoryLimit:this.validatePositiveNumber(r.memoryLimit,128),timeout:this.validatePositiveNumber(r.timeout,3e4),enableAsync:r.enableAsync??!0,enableGenerators:r.enableGenerators??!1,enableProxies:r.enableProxies??!1,enableSymbols:r.enableSymbols??!0,maxContextSize:this.validatePositiveNumber(r.maxContextSize,10485760),recycleIsolates:r.recycleIsolates??!1,isolatePoolSize:this.validatePositiveNumber(r.isolatePoolSize,1)}}async execute(e,r={},a={}){let o=null,s=null;const i=process.env.DEBUG&&!1;try{s=new t.VMEngineFactory(this.appContext).create("quickjs"),await s.initialize(this.config),o=await s.createContext();const l=r.console||a.enableConsole,c=r.console||{log:(...e)=>console.log(...e),error:(...e)=>console.error(...e),warn:(...e)=>console.warn(...e),info:(...e)=>console.info(...e),debug:(...e)=>console.debug(...e)};if(l)try{await o.eval("\n            globalThis.console = {\n              log: function(...args) {\n                // Convert args to a format that can be passed back to host\n                const serializedArgs = args.map(arg => {\n                  if (typeof arg === 'object' && arg !== null) {\n                    try { return JSON.stringify(arg); } catch { return String(arg); }\n                  }\n                  return String(arg);\n                });\n                // Store for later processing\n                if (!globalThis.__consoleCalls) globalThis.__consoleCalls = [];\n                globalThis.__consoleCalls.push({ method: 'log', args: serializedArgs });\n                return undefined;\n              },\n              error: function(...args) {\n                const serializedArgs = args.map(arg => {\n                  if (typeof arg === 'object' && arg !== null) {\n                    try { return JSON.stringify(arg); } catch { return String(arg); }\n                  }\n                  return String(arg);\n                });\n                if (!globalThis.__consoleCalls) globalThis.__consoleCalls = [];\n                globalThis.__consoleCalls.push({ method: 'error', args: serializedArgs });\n                return undefined;\n              },\n              warn: function(...args) {\n                const serializedArgs = args.map(arg => {\n                  if (typeof arg === 'object' && arg !== null) {\n                    try { return JSON.stringify(arg); } catch { return String(arg); }\n                  }\n                  return String(arg);\n                });\n                if (!globalThis.__consoleCalls) globalThis.__consoleCalls = [];\n                globalThis.__consoleCalls.push({ method: 'warn', args: serializedArgs });\n                return undefined;\n              },\n              info: function(...args) {\n                const serializedArgs = args.map(arg => {\n                  if (typeof arg === 'object' && arg !== null) {\n                    try { return JSON.stringify(arg); } catch { return String(arg); }\n                  }\n                  return String(arg);\n                });\n                if (!globalThis.__consoleCalls) globalThis.__consoleCalls = [];\n                globalThis.__consoleCalls.push({ method: 'info', args: serializedArgs });\n                return undefined;\n              },\n              debug: function(...args) {\n                const serializedArgs = args.map(arg => {\n                  if (typeof arg === 'object' && arg !== null) {\n                    try { return JSON.stringify(arg); } catch { return String(arg); }\n                  }\n                  return String(arg);\n                });\n                if (!globalThis.__consoleCalls) globalThis.__consoleCalls = [];\n                globalThis.__consoleCalls.push({ method: 'debug', args: serializedArgs });\n                return undefined;\n              }\n            };\n          ")}catch(e){}let u=!1;for(const[e,n]of Object.entries(r))["JSON","Math","Date","Array","Object","String","Number","Boolean","console"].includes(e)||("$"===e?await this.setupSmartDollar(o,n):"_"===e?u=!0:await o.setGlobal(e,n));if(u){const{createVMLodashCode:e}=await n.e(674).then(n.bind(n,674)),r=e();await o.eval(r),i&&await o.eval("typeof globalThis._")}const g=this.wrapCode(e),b=await s.execute(o,g,{},{...a,timeout:a.timeout??this.config.timeout});if(l)try{const e=await o.eval("globalThis.__consoleCalls");if(Array.isArray(e))for(const r of e)if(r&&"object"==typeof r&&"method"in r&&"args"in r){const e=r,n=e.method;"log"!==n&&"error"!==n&&"warn"!==n&&"info"!==n&&"debug"!==n||Array.isArray(e.args)&&c[n](...e.args)}}catch(e){}let f=b.value;if(null!=f&&"object"==typeof f)try{const e="\n            (function(obj) {\n              if (obj && obj.__isSmartDollar) {\n                return obj._value || obj.value;\n              }\n              return obj;\n            })(globalThis.__result__)\n          ";await o.setGlobal("__result__",f),f=await o.eval(e),await o.eval("delete globalThis.__result__")}catch(e){console.error("Failed to unwrap SmartDollar:",e)}try{await o.eval("\n          delete globalThis.__result__;\n          delete globalThis.__consoleCalls;\n        ")}catch(e){}return{value:f,executionTime:b.executionTime,memoryUsed:b.memoryUsed||0}}catch(e){if(process.env.DEBUG&&(console.error("VMSandboxQuickJS execute error:",e),e instanceof Error&&(console.error("Error message:",e.message),console.error("Error stack:",e.stack))),e instanceof Error&&(e.message.includes("dynamic import callback")||e.message.includes("experimental-vm-modules")||e.message.includes("ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG"))){const e=new Error("QuickJS initialization failed: Dynamic imports are not supported in the current Jest environment. QuickJS requires --experimental-vm-modules flag which may not be compatible with your Node.js version. Run tests with NODE_OPTIONS=--experimental-vm-modules.");throw this.createSandboxError(e,0)}throw this.createSandboxError(e,0)}finally{if(s)try{await s.dispose()}catch{}}}async setupSmartDollar(e,r){let t;t=Array.isArray(r)?[...r]:"function"==typeof r?r.valueOf?r.valueOf():r():r;const{createVMSmartDollarCodeV2:a}=await n.e(247).then(n.bind(n,247)),o=`\n      const smartDollarModule = ${a()};\n      const { createSmartDollar, SmartDollar } = smartDollarModule;\n      const $_data = ${JSON.stringify(t)};\n      \n      // Store SmartDollar class and creator globally for cleanup and method access\n      globalThis.SmartDollar = SmartDollar;\n      globalThis.createSmartDollar = createSmartDollar;\n      \n      // Override Object.keys to handle SmartDollar objects\n      const originalObjectKeys = Object.keys;\n      Object.keys = function(obj) {\n        if (obj && obj.__isSmartDollar && obj._value !== null && obj._value !== undefined) {\n          return originalObjectKeys(obj._value);\n        }\n        return originalObjectKeys(obj);\n      };\n      \n      // Override Object.values to handle SmartDollar objects\n      const originalObjectValues = Object.values;\n      Object.values = function(obj) {\n        if (obj && obj.__isSmartDollar && obj._value !== null && obj._value !== undefined) {\n          return originalObjectValues(obj._value);\n        }\n        return originalObjectValues(obj);\n      };\n      \n      // Override Object.entries to handle SmartDollar objects\n      const originalObjectEntries = Object.entries;\n      Object.entries = function(obj) {\n        if (obj && obj.__isSmartDollar && obj._value !== null && obj._value !== undefined) {\n          return originalObjectEntries(obj._value);\n        }\n        return originalObjectEntries(obj);\n      };\n      \n      // Create SmartDollar instance\n      if ($_data === null || $_data === undefined) {\n        globalThis.$ = $_data;\n      } else {\n        // Always use Proxy-based SmartDollar for consistent behavior\n        globalThis.$ = createSmartDollar($_data);\n      }\n    `;await e.eval(o)}wrapCode(e){const r=e.trim();if(e.includes("await")||e.includes("async")||e.includes("Promise."))return`(async () => {\n        try {\n          const result = ${e};\n          // Unwrap SmartDollar if needed\n          if (result && result.__isSmartDollar) {\n            return result._value || result.value;\n          }\n          return result;\n        } catch (e) {\n          throw e;\n        }\n      })()`;if(/^\s*(const|let|var|function|class|if|for|while|do|switch)\s+/.test(r)||/;\s*$/.test(r)){const n=[];let t="",a=!1,o=null,s=0;for(let e=0;e<r.length;e++){const i=r[e],l=e>0?r[e-1]:"";a||'"'!==i&&"'"!==i&&"`"!==i?a&&i===o&&"\\"!==l&&(a=!1):(a=!0,o=i),a||("("!==i&&"{"!==i&&"["!==i||s++,")"!==i&&"}"!==i&&"]"!==i||s--,";"!==i||0!==s)?t+=i:(n.push(t.trim()),t="")}if(t.trim()&&n.push(t.trim()),n.length>1){const e=n[n.length-1];if(e&&!e.startsWith("const ")&&!e.startsWith("let ")&&!e.startsWith("var ")&&!e.startsWith("function ")&&!e.startsWith("class ")&&!e.startsWith("if ")&&!e.startsWith("for ")&&!e.startsWith("while ")&&!e.startsWith("return "))return`(() => {\n              try {\n                ${n.slice(0,-1).join(";\n")};\n                return (${e});\n              } catch (error) {\n                if (error instanceof Error) {\n                  throw new Error(error.message);\n                }\n                throw error;\n              }\n            })()`}return`(() => {\n          try {\n            ${e}\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(error.message);\n            }\n            throw error;\n          }\n        })()`}return`(() => {\n          try {\n            return (${e});\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(error.message);\n            }\n            throw error;\n          }\n        })()`}createSandboxError(e,r){let n="EXECUTION_ERROR",t="Unknown error";e instanceof Error?(t=e.message,"TimeoutError"===e.name&&(n="TIMEOUT")):"string"==typeof e&&(t=e);const a=t.toLowerCase();a.includes("timeout")||a.includes("timed out")?n="TIMEOUT":a.includes("memory")?n="MEMORY_LIMIT":a.includes("syntax")?n="SYNTAX_ERROR":a.includes("reference")||a.includes("is not defined")?n="REFERENCE_ERROR":a.includes("type")&&(n="TYPE_ERROR");const o=new Error(t);return o.code=n,o.details={executionTime:r},o.name="SandboxError",o}async dispose(){}getConfig(){return{...this.config}}getCapabilities(){return{console:!0,json:!0,math:!0,array:!0,object:!0,promises:this.config.enableAsync,generators:this.config.enableGenerators,proxies:this.config.enableProxies,symbols:this.config.enableSymbols,buffer:!1,crypto:!1,timers:!1,weakmap:!0,intl:!1,number:!0}}getPoolStatus(){return{size:0,maxSize:0,available:0,busy:0}}validateContextValue(e){try{const r=this.estimateValueSize(e);return r>this.config.maxContextSize?{valid:!1,error:`Context value too large: ${r} bytes > ${this.config.maxContextSize} bytes`}:{valid:!0}}catch(e){return{valid:!1,error:`Validation error: ${e instanceof Error?e.message:"Unknown error"}`}}}estimateValueSize(e,r=new Set){if(null==e)return 8;if("object"==typeof e&&null!==e&&r.has(e))return 8;switch(typeof e){case"boolean":return 4;case"number":default:return 8;case"string":return 2*e.length;case"bigint":case"function":return 2*e.toString().length;case"object":{if(r.has(e))return 8;r.add(e);let n=16;if(Array.isArray(e))for(const t of e)n+=this.estimateValueSize(t,r);else if(e instanceof Date)n+=8;else if(e instanceof RegExp)n+=2*e.toString().length;else if(e instanceof Map)for(const[t,a]of e)n+=this.estimateValueSize(t,r),n+=this.estimateValueSize(a,r);else if(e instanceof Set)for(const t of e)n+=this.estimateValueSize(t,r);else for(const[t,a]of Object.entries(e))n+=2*t.length,n+=this.estimateValueSize(a,r);return r.delete(e),n}}}validatePositiveNumber(e,r){return"number"==typeof e&&e>0&&!Number.isNaN(e)?e:r}}}}]);