"use strict";(this.webpackChunkJSQ=this.webpackChunkJSQ||[]).push([[247],{247:(n,e,t)=>{t.d(e,{createVMSmartDollarCodeV2:()=>a});const r="\nif (typeof smartDollarMethods === 'undefined') {\n  // Helper function to create new instances  \n  const createNewInstance = function(data) {\n    // Check if we can use the constructor\n    if (this && this.constructor) {\n      try {\n        return new this.constructor(data);\n      } catch (e) {\n        // Constructor might not work properly in all contexts\n      }\n    }\n    \n    // If we have access to global SmartDollar with createInstance, use it\n    if (typeof globalThis.SmartDollar !== 'undefined' && \n        typeof globalThis.SmartDollar.createInstance === 'function') {\n      return globalThis.SmartDollar.createInstance(data);\n    }\n    \n    // Otherwise try direct SmartDollar constructor\n    if (typeof globalThis.SmartDollar !== 'undefined') {\n      return new globalThis.SmartDollar(data);\n    }\n    \n    // Fallback: return raw data\n    return data;\n  };\n  \n  globalThis.smartDollarMethods = {\n  // Array methods\n  map: function(dataOrFn, fn) {\n    // Handle both $.map(array, fn) and array.map(fn) usage\n    let data, mapFn;\n    if (arguments.length === 1) {\n      // Instance method: array.map(fn)\n      data = this._value;\n      mapFn = dataOrFn;\n    } else {\n      // Static method: $.map(array, fn)\n      data = dataOrFn;\n      mapFn = fn;\n    }\n    \n    if (data === null || data === undefined) {\n      return createNewInstance.call(this, []);\n    }\n    const mapped = Array.from(data).map((item, index) => mapFn(item, index, data));\n    return createNewInstance.call(this, mapped);\n  },\n  \n  filter: function(dataOrFn, fn) {\n    // Handle both $.filter(array, fn) and array.filter(fn) usage\n    let data, filterFn;\n    if (arguments.length === 1) {\n      // Instance method: array.filter(fn)\n      data = this._value;\n      filterFn = dataOrFn;\n    } else {\n      // Static method: $.filter(array, fn)\n      data = dataOrFn;\n      filterFn = fn;\n    }\n    \n    if (data === null || data === undefined) {\n      return createNewInstance.call(this, []);\n    }\n    const filtered = Array.from(data).filter((item, index) => filterFn(item, index, data));\n    return createNewInstance.call(this, filtered);\n  },\n  \n  reduce: function(fn, initial) {\n    if (this._value === null || this._value === undefined) {\n      return initial;\n    }\n    return Array.from(this._value).reduce(fn, initial);\n  },\n  \n  slice: function(start, end) {\n    if (this._value === null || this._value === undefined) {\n      return createNewInstance.call(this, []);\n    }\n    const sliced = Array.from(this._value).slice(start, end);\n    return createNewInstance.call(this, sliced);\n  },\n  \n  concat: function(...args) {\n    // Unwrap any SmartDollar instances in the arguments\n    const unwrappedArgs = args.map(arg => {\n      if (arg && typeof arg === 'object' && arg.__isSmartDollar) {\n        return arg._value;\n      }\n      return arg;\n    });\n    const concatenated = Array.from(this._value).concat(...unwrappedArgs);\n    return createNewInstance.call(this, concatenated);\n  },\n  \n  push: function(...elements) {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      return this._value.push(...elements);\n    }\n    // Fallback for non-arrays\n    const arr = Array.from(this._value);\n    arr.push(...elements);\n    return arr.length;\n  },\n  \n  pop: function() {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      return this._value.pop();\n    }\n    // Fallback for non-arrays\n    const arr = Array.from(this._value);\n    return arr.pop();\n  },\n  \n  shift: function() {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      return this._value.shift();\n    }\n    // Fallback for non-arrays\n    const arr = Array.from(this._value);\n    return arr.shift();\n  },\n  \n  unshift: function(...elements) {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      return this._value.unshift(...elements);\n    }\n    // Fallback for non-arrays\n    const arr = Array.from(this._value);\n    arr.unshift(...elements);\n    return arr.length;\n  },\n  \n  splice: function(start, deleteCount, ...items) {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      return this._value.splice(start, deleteCount, ...items);\n    }\n    // Fallback for non-arrays\n    const arr = Array.from(this._value);\n    return arr.splice(start, deleteCount, ...items);\n  },\n  \n  find: function(fn) {\n    const found = Array.from(this._value).find((item, index) => fn(item, index, this._value));\n    return found !== undefined ? new this.constructor(found) : new this.constructor(null);\n  },\n  \n  some: function(fn) {\n    return Array.from(this._value).some((item, index) => fn(item, index, this._value));\n  },\n  \n  every: function(fn) {\n    return Array.from(this._value).every((item, index) => fn(item, index, this._value));\n  },\n  \n  includes: function(searchElement, fromIndex) {\n    return Array.from(this._value).includes(searchElement, fromIndex);\n  },\n  \n  indexOf: function(searchElement, fromIndex) {\n    return Array.from(this._value).indexOf(searchElement, fromIndex);\n  },\n  \n  lastIndexOf: function(searchElement, fromIndex) {\n    // Manual implementation due to weird issue with Array.from and new Function\n    const arr = Array.isArray(this._value) ? this._value : Array.from(this._value);\n    const len = arr.length;\n    \n    if (len === 0) return -1;\n    \n    let n = fromIndex == null ? len - 1 : Number(fromIndex);\n    \n    if (n >= len) {\n      n = len - 1;\n    } else if (n < 0) {\n      n = len + n;\n      if (n < 0) return -1;\n    }\n    \n    for (let i = n; i >= 0; i--) {\n      if (arr[i] === searchElement) {\n        return i;\n      }\n    }\n    \n    return -1;\n  },\n  \n  findIndex: function(predicate, thisArg) {\n    return Array.from(this._value).findIndex(predicate, thisArg);\n  },\n  \n  join: function(separator) {\n    return Array.from(this._value).join(separator);\n  },\n  \n  reverse: function() {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      this._value.reverse();\n      return this; // Return this for chaining\n    }\n    // Fallback for non-arrays\n    const reversed = Array.from(this._value).reverse();\n    return createNewInstance.call(this, reversed);\n  },\n  \n  sort: function(compareFn) {\n    // Mutate the original array if it's an array\n    if (Array.isArray(this._value)) {\n      this._value.sort(compareFn);\n      return this; // Return this for chaining\n    }\n    // Fallback for non-arrays\n    const sorted = Array.from(this._value).sort(compareFn);\n    return createNewInstance.call(this, sorted);\n  },\n  \n  // Object methods\n  keys: function() {\n    const keys = Object.keys(this._value);\n    return createNewInstance.call(this, keys);\n  },\n  \n  values: function() {\n    const values = Object.values(this._value);\n    return createNewInstance.call(this, values);\n  },\n  \n  entries: function() {\n    const entries = Object.entries(this._value);\n    return createNewInstance.call(this, entries);\n  },\n  \n  hasOwn: function(prop) {\n    return Object.hasOwn(this._value, prop);\n  },\n  \n  assign: function(...sources) {\n    const assigned = Object.assign({}, this._value, ...sources);\n    return createNewInstance.call(this, assigned);\n  },\n  \n  // String methods\n  split: function(separator, limit) {\n    const parts = String(this._value).split(separator, limit);\n    return createNewInstance.call(this, parts);\n  },\n  \n  replace: function(search, replacement) {\n    const replaced = String(this._value).replace(search, replacement);\n    return createNewInstance.call(this, replaced);\n  },\n  \n  replaceAll: function(search, replacement) {\n    const replaced = String(this._value).replaceAll(search, replacement);\n    return createNewInstance.call(this, replaced);\n  },\n  \n  toLowerCase: function() {\n    const lowered = String(this._value).toLowerCase();\n    return createNewInstance.call(this, lowered);\n  },\n  \n  toUpperCase: function() {\n    const uppered = String(this._value).toUpperCase();\n    return createNewInstance.call(this, uppered);\n  },\n  \n  trim: function() {\n    const trimmed = String(this._value).trim();\n    return createNewInstance.call(this, trimmed);\n  },\n  \n  substring: function(start, end) {\n    const sub = String(this._value).substring(start, end);\n    return createNewInstance.call(this, sub);\n  },\n  \n  charAt: function(index) {\n    return String(this._value).charAt(index);\n  },\n  \n  charCodeAt: function(index) {\n    return String(this._value).charCodeAt(index);\n  },\n  \n  startsWith: function(searchString, position) {\n    return String(this._value).startsWith(searchString, position);\n  },\n  \n  endsWith: function(searchString, position) {\n    return String(this._value).endsWith(searchString, position);\n  },\n  \n  padStart: function(targetLength, padString) {\n    const padded = String(this._value).padStart(targetLength, padString);\n    return createNewInstance.call(this, padded);\n  },\n  \n  padEnd: function(targetLength, padString) {\n    const padded = String(this._value).padEnd(targetLength, padString);\n    return createNewInstance.call(this, padded);\n  },\n  \n  match: function(regexp) {\n    const matches = String(this._value).match(regexp);\n    return matches ? new this.constructor(matches) : new this.constructor(null);\n  },\n  \n  search: function(regexp) {\n    return String(this._value).search(regexp);\n  },\n  \n  // Number methods\n  toFixed: function(digits) {\n    return Number(this._value).toFixed(digits);\n  },\n  \n  toExponential: function(fractionDigits) {\n    return Number(this._value).toExponential(fractionDigits);\n  },\n  \n  toPrecision: function(precision) {\n    return Number(this._value).toPrecision(precision);\n  },\n  \n  // Type conversion methods\n  toString: function() {\n    if (this._value === null || this._value === undefined) {\n      return '';\n    }\n    return String(this._value);\n  },\n  \n  toNumber: function() {\n    return Number(this._value);\n  },\n  \n  toBoolean: function() {\n    return Boolean(this._value);\n  },\n  \n  toArray: function() {\n    if (Array.isArray(this._value)) {\n      return Array.from(this._value);\n    }\n    if (this._value && typeof this._value === 'object' && this._value.constructor === Object) {\n      return Object.entries(this._value);\n    }\n    return [this._value];\n  },\n  \n  // Utility methods\n  pipe: function(...fns) {\n    return fns.reduce((acc, fn) => new this.constructor(fn(acc._value)), this);\n  },\n  \n  tap: function(fn) {\n    fn(this._value);\n    return this;\n  },\n  \n  value: function() {\n    // Also update public value property for VM unwrapping\n    this.value = this._value;\n    return this._value;\n  },\n  \n  valueOf: function() {\n    return this._value;\n  },\n  \n  isNull: function() {\n    return this._value === null;\n  },\n  \n  isUndefined: function() {\n    return this._value === undefined;\n  },\n  \n  isNullOrUndefined: function() {\n    return this._value === null || this._value === undefined;\n  },\n  \n  isEmpty: function() {\n    if (this._value === null || this._value === undefined) return true;\n    if (Array.isArray(this._value)) return this._value.length === 0;\n    if (typeof this._value === 'string') return this._value.length === 0;\n    if (typeof this._value === 'object') return Object.keys(this._value).length === 0;\n    return false;\n  },\n  \n  // Chainable conditions\n  when: function(condition, trueFn, falseFn) {\n    if (condition) {\n      return trueFn ? new this.constructor(trueFn(this._value)) : this;\n    } else {\n      return falseFn ? new this.constructor(falseFn(this._value)) : this;\n    }\n  },\n  \n  unless: function(condition, fn) {\n    return this.when(!condition, fn);\n  },\n  \n  // Lodash-like methods\n  where: function(properties, value) {\n    const filtered = Array.from(this._value).filter(item => {\n      if (!item || typeof item !== 'object') return false;\n      \n      // If called with two arguments (key, value)\n      if (typeof properties === 'string' && value !== undefined) {\n        return item[properties] === value;\n      }\n      \n      // If called with object (properties)\n      if (typeof properties === 'object' && properties !== null) {\n        return Object.entries(properties).every(([key, val]) => item[key] === val);\n      }\n      \n      return false;\n    });\n    return createNewInstance.call(this, filtered);\n  },\n  \n  pluck: function(property) {\n    const plucked = Array.from(this._value).map(item => item ? item[property] : undefined);\n    return createNewInstance.call(this, plucked);\n  },\n  \n  sortBy: function(iteratee) {\n    const sorted = Array.from(this._value).sort((a, b) => {\n      const aVal = typeof iteratee === 'function' ? iteratee(a) : a[iteratee];\n      const bVal = typeof iteratee === 'function' ? iteratee(b) : b[iteratee];\n      if (aVal < bVal) return -1;\n      if (aVal > bVal) return 1;\n      return 0;\n    });\n    return createNewInstance.call(this, sorted);\n  },\n  \n  groupBy: function(iteratee) {\n    const grouped = Array.from(this._value).reduce((acc, item) => {\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (!acc[key]) acc[key] = [];\n      acc[key].push(item);\n      return acc;\n    }, {});\n    return createNewInstance.call(this, grouped);\n  },\n  \n  countBy: function(iteratee) {\n    const counted = Array.from(this._value).reduce((acc, item) => {\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      acc[key] = (acc[key] || 0) + 1;\n      return acc;\n    }, {});\n    return createNewInstance.call(this, counted);\n  },\n  \n  take: function(n) {\n    const taken = Array.from(this._value).slice(0, n);\n    return createNewInstance.call(this, taken);\n  },\n  \n  skip: function(n) {\n    const skipped = Array.from(this._value).slice(n);\n    return createNewInstance.call(this, skipped);\n  },\n  \n  uniqBy: function(iteratee) {\n    const seen = new Map();\n    const unique = Array.from(this._value).filter(item => {\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (seen.has(key)) return false;\n      seen.set(key, true);\n      return true;\n    });\n    return createNewInstance.call(this, unique);\n  },\n  \n  flatten: function() {\n    const flattened = Array.from(this._value).reduce((acc, val) => \n      acc.concat(Array.isArray(val) ? val : [val]), []);\n    return createNewInstance.call(this, flattened);\n  },\n  \n  flatMap: function(fn) {\n    if (this._value === null || this._value === undefined) {\n      return createNewInstance.call(this, []);\n    }\n    const mapped = Array.from(this._value).flatMap((item, index) => fn(item, index, this._value));\n    return createNewInstance.call(this, mapped);\n  },\n  \n  flattenDeep: function(data) {\n    const flattenDeepRecursive = (arr) => {\n      return arr.reduce((acc, val) => \n        acc.concat(Array.isArray(val) ? flattenDeepRecursive(val) : val), []);\n    };\n    // If called with an argument, use that instead of this._value\n    const target = arguments.length > 0 ? data : this._value;\n    const flattened = flattenDeepRecursive(Array.from(target));\n    return createNewInstance.call(this, flattened);\n  },\n  \n  compact: function(data) {\n    // If called with an argument, use that instead of this._value\n    const target = arguments.length > 0 ? data : this._value;\n    const compacted = Array.from(target).filter(Boolean);\n    return createNewInstance.call(this, compacted);\n  },\n  \n  chunk: function(size) {\n    const arr = Array.from(this._value);\n    const chunks = [];\n    for (let i = 0; i < arr.length; i += size) {\n      chunks.push(arr.slice(i, i + size));\n    }\n    return createNewInstance.call(this, chunks);\n  },\n  \n  sum: function(key) {\n    const arr = Array.from(this._value);\n    if (key && typeof key === 'string') {\n      return arr.reduce((acc, val) => acc + (Number(val?.[key]) || 0), 0);\n    }\n    return arr.reduce((acc, val) => acc + (Number(val) || 0), 0);\n  },\n  \n  mean: function() {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return NaN;\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += Number(arr[i]) || 0;\n    }\n    return sum / arr.length;\n  },\n  \n  size: function() {\n    if (Array.isArray(this._value) || typeof this._value === 'string') {\n      return this._value.length;\n    }\n    if (this._value && typeof this._value === 'object') {\n      return Object.keys(this._value).length;\n    }\n    return 0;\n  },\n  \n  orderBy: function(iteratees, orders) {\n    const arr = Array.from(this._value);\n    const iterateeArr = Array.isArray(iteratees) ? iteratees : [iteratees];\n    const orderArr = Array.isArray(orders) ? orders : [orders];\n    \n    const sorted = arr.sort((a, b) => {\n      for (let i = 0; i < iterateeArr.length; i++) {\n        const iteratee = iterateeArr[i];\n        const order = orderArr[i] || 'asc';\n        const aVal = typeof iteratee === 'function' ? iteratee(a) : a[iteratee];\n        const bVal = typeof iteratee === 'function' ? iteratee(b) : b[iteratee];\n        \n        if (aVal < bVal) return order === 'asc' ? -1 : 1;\n        if (aVal > bVal) return order === 'asc' ? 1 : -1;\n      }\n      return 0;\n    });\n    return createNewInstance.call(this, sorted);\n  },\n  \n  keyBy: function(iteratee) {\n    const keyed = Array.from(this._value).reduce((acc, item) => {\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      acc[key] = item;\n      return acc;\n    }, {});\n    return createNewInstance.call(this, keyed);\n  },\n  \n  takeWhile: function(predicate) {\n    const arr = Array.from(this._value);\n    const taken = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) break;\n      taken.push(arr[i]);\n    }\n    return createNewInstance.call(this, taken);\n  },\n  \n  dropWhile: function(predicate) {\n    const arr = Array.from(this._value);\n    let dropIndex = 0;\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) {\n        dropIndex = i;\n        break;\n      }\n    }\n    return createNewInstance.call(this, arr.slice(dropIndex));\n  },\n  \n  min: function() {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return Math.min(...arr);\n  },\n  \n  max: function() {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return Math.max(...arr);\n  },\n  \n  minBy: function(iteratee) {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return arr.reduce((min, item) => {\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      const minVal = typeof iteratee === 'function' ? iteratee(min) : min[iteratee];\n      return itemVal < minVal ? item : min;\n    });\n  },\n  \n  maxBy: function(iteratee) {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return arr.reduce((max, item) => {\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      const maxVal = typeof iteratee === 'function' ? iteratee(max) : max[iteratee];\n      return itemVal > maxVal ? item : max;\n    });\n  },\n  \n  sample: function() {\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return arr[Math.floor(Math.random() * arr.length)];\n  },\n  \n  sampleSize: function(n) {\n    const arr = Array.from(this._value);\n    const shuffled = [...arr].sort(() => Math.random() - 0.5);\n    return createNewInstance.call(this, shuffled.slice(0, n));\n  },\n  \n  shuffle: function() {\n    const arr = Array.from(this._value);\n    const shuffled = [...arr].sort(() => Math.random() - 0.5);\n    return createNewInstance.call(this, shuffled);\n  },\n  \n  // Async methods\n  mapAsync: async function(fn) {\n    // Convert to array using same logic as toArray method\n    let arr;\n    if (Array.isArray(this._value)) {\n      arr = Array.from(this._value);\n    } else {\n      // For non-arrays, treat as single value\n      arr = [this._value];\n    }\n    const promises = arr.map((item, index) => fn(item, index, arr));\n    const results = await Promise.all(promises);\n    return createNewInstance.call(this, results);\n  },\n  \n  mapAsyncSeq: async function(fn) {\n    const results = [];\n    // Convert to array using same logic as toArray method\n    let arr;\n    if (Array.isArray(this._value)) {\n      arr = Array.from(this._value);\n    } else {\n      // For non-arrays, treat as single value\n      arr = [this._value];\n    }\n    for (let i = 0; i < arr.length; i++) {\n      results.push(await fn(arr[i], i, arr));\n    }\n    return createNewInstance.call(this, results);\n  },\n  \n  forEachAsync: async function(fn) {\n    // Convert to array using same logic as toArray method\n    let arr;\n    if (Array.isArray(this._value)) {\n      arr = Array.from(this._value);\n    } else {\n      // For non-arrays, treat as single value\n      arr = [this._value];\n    }\n    const promises = arr.map((item, index) => fn(item, index, arr));\n    await Promise.all(promises);\n  },\n  \n  forEachAsyncSeq: async function(fn) {\n    // Convert to array using same logic as toArray method\n    let arr;\n    if (Array.isArray(this._value)) {\n      arr = Array.from(this._value);\n    } else {\n      // For non-arrays, treat as single value\n      arr = [this._value];\n    }\n    for (let i = 0; i < arr.length; i++) {\n      await fn(arr[i], i, arr);\n    }\n  }\n};\n}\n";function a(){return`\n// SmartDollar implementation without global variables\n(function() {\n  ${r}\n  \n  // Forward declare createSmartDollar\n  let createSmartDollar;\n  \n  // Define SmartDollar class\n  class SmartDollar {\n    constructor(value) {\n      // If createSmartDollar is available and we're not already in it, use it\n      if (createSmartDollar && !this.__bypassProxy) {\n        return createSmartDollar(value);\n      }\n      \n      this._value = value;\n      this.__isSmartDollar = true;\n    }\n    \n    get length() {\n      if (Array.isArray(this._value)) {\n        return this._value.length;\n      }\n      if (typeof this._value === 'string') {\n        return this._value.length;\n      }\n      if (this._value && typeof this._value === 'object') {\n        return Object.keys(this._value).length;\n      }\n      return 0;\n    }\n    \n    valueOf() {\n      return this._value;\n    }\n    \n    toString() {\n      if (this._value === null) return '';\n      if (this._value === undefined) return '';\n      if (typeof this._value === 'string') return this._value;\n      return JSON.stringify(this._value);\n    }\n    \n    toJSON() {\n      return this._value;\n    }\n    \n    [Symbol.iterator]() {\n      if (this._value === null || this._value === undefined) {\n        return [][Symbol.iterator]();\n      }\n      if (Array.isArray(this._value) || typeof this._value === 'string') {\n        return this._value[Symbol.iterator]();\n      }\n      if (this._value && typeof this._value === 'object') {\n        return Object.entries(this._value)[Symbol.iterator]();\n      }\n      return [][Symbol.iterator]();\n    }\n  }\n  \n  \n  // Add static method to create instances (will be defined after createSmartDollar)\n  SmartDollar.createInstance = null;\n  \n  // Apply all shared methods to SmartDollar prototype\n  // smartDollarMethods should be defined by SMART_DOLLAR_METHODS above\n  if (typeof globalThis.smartDollarMethods !== 'undefined') {\n    Object.keys(globalThis.smartDollarMethods).forEach(method => {\n      SmartDollar.prototype[method] = globalThis.smartDollarMethods[method];\n    });\n  }\n  \n  // Create $ function with Proxy wrapper\n  createSmartDollar = function(data) {\n    if (data === null || data === undefined) {\n      return data;\n    }\n    \n    // Create raw instance without proxy\n    const smartDollar = Object.create(SmartDollar.prototype);\n    smartDollar._value = data;\n    smartDollar.__isSmartDollar = true;\n    \n    // Create proxy to handle property access\n    return new Proxy(smartDollar, {\n      get(target, prop, receiver) {\n        // Special properties that should always come from SmartDollar\n        const smartDollarOnlyProps = ['_value', '__isSmartDollar', 'constructor', 'length', Symbol.iterator, Symbol.toPrimitive];\n        \n        // Check SmartDollar-only properties FIRST\n        if (smartDollarOnlyProps.includes(prop)) {\n          const value = target[prop];\n          if (typeof value === 'function') {\n            return value.bind(target);\n          }\n          return value;\n        }\n        \n        // Handle numeric indices for arrays\n        if (typeof prop === 'string' && !isNaN(Number(prop))) {\n          const index = Number(prop);\n          if (Array.isArray(target._value) && index >= 0 && index < target._value.length) {\n            const item = target._value[index];\n            return item !== null && item !== undefined && typeof item === 'object'\n              ? createSmartDollar(item)\n              : item;\n          }\n        }\n        \n        // Check wrapped value properties FIRST for non-method properties\n        // This ensures properties like 'value' on the data object are accessible\n        if (target._value !== null && target._value !== undefined && typeof target._value === 'object' && prop in target._value) {\n          const valueFromData = target._value[prop];\n          \n          // If it's a method on SmartDollar AND a property on the data,\n          // prioritize SmartDollar methods ONLY for array/collection methods\n          const smartDollarMethod = target[prop];\n          const isArrayMethod = ['filter', 'map', 'reduce', 'find', 'some', 'every', 'forEach', \n                                'pluck', 'where', 'sortBy', 'groupBy', 'countBy', 'take', 'skip',\n                                'uniqBy', 'flatten', 'compact', 'chunk', 'orderBy', 'keyBy',\n                                'takeWhile', 'dropWhile', 'flattenDeep', 'reverse', 'sum',\n                                'mean', 'min', 'max', 'minBy', 'maxBy', 'sample', 'sampleSize',\n                                'size', 'isEmpty', 'includes', 'flatMap', 'concat', 'slice', \n                                'push', 'pop', 'shift', 'unshift', 'splice', 'indexOf', \n                                'lastIndexOf', 'join', 'sort', 'fill'].includes(prop);\n          \n          if (smartDollarMethod && typeof smartDollarMethod === 'function' && isArrayMethod) {\n            return smartDollarMethod.bind(target);\n          }\n          \n          // Otherwise, return the data property\n          if (valueFromData !== undefined) {\n            return valueFromData !== null && typeof valueFromData === 'object'\n              ? createSmartDollar(valueFromData)\n              : valueFromData;\n          }\n        }\n        \n        // Then check if property exists on SmartDollar instance (methods)\n        if (prop in target) {\n          const value = target[prop];\n          if (typeof value === 'function') {\n            return value.bind(target);\n          }\n          return value;\n        }\n        \n        return undefined;\n      },\n      \n      set(target, prop, value) {\n        // Allow setting properties on the wrapped value\n        if (target._value !== null && target._value !== undefined && typeof target._value === 'object') {\n          target._value[prop] = value;\n          return true;\n        }\n        return false;\n      },\n      \n      has(target, prop) {\n        if (prop in target) return true;\n        if (target._value !== null && target._value !== undefined) {\n          return prop in target._value;\n        }\n        return false;\n      },\n      \n      ownKeys(target) {\n        // Return keys from the wrapped value, not SmartDollar's properties\n        if (target._value !== null && target._value !== undefined && typeof target._value === 'object') {\n          return Reflect.ownKeys(target._value);\n        }\n        return [];\n      },\n      \n      getOwnPropertyDescriptor(target, prop) {\n        // Return descriptor from the wrapped value for Object.keys() to work\n        if (target._value !== null && target._value !== undefined && typeof target._value === 'object' && prop in target._value) {\n          return Object.getOwnPropertyDescriptor(target._value, prop);\n        }\n        return undefined;\n      }\n    });\n  };\n  \n  // Now that createSmartDollar is defined, set the static method\n  SmartDollar.createInstance = createSmartDollar;\n  \n  // Return the creator function and class\n  return { createSmartDollar, SmartDollar };\n})();\n`}}}]);