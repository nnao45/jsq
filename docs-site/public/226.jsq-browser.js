"use strict";(this.webpackChunkJSQ=this.webpackChunkJSQ||[]).push([[226],{201:(n,t,e)=>{e.d(t,{v:()=>r});const r="\n// Always define lodashMethods\nglobalThis.lodashMethods = {\n  // Array methods from lodash\n  filter: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const filtered = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        filtered.push(arr[i]);\n      }\n    }\n    return new this.constructor(filtered);\n  },\n  \n  map: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const mapped = [];\n    for (let i = 0; i < arr.length; i++) {\n      mapped.push(iteratee(arr[i], i, this._value));\n    }\n    return new this.constructor(mapped);\n  },\n  \n  find: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        return arr[i];\n      }\n    }\n    return undefined;\n  },\n  \n  findIndex: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return -1;\n    }\n    const arr = Array.from(this._value);\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        return i;\n      }\n    }\n    return -1;\n  },\n  \n  findLast: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (predicate(arr[i], i, this._value)) {\n        return arr[i];\n      }\n    }\n    return undefined;\n  },\n  \n  findLastIndex: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return -1;\n    }\n    const arr = Array.from(this._value);\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (predicate(arr[i], i, this._value)) {\n        return i;\n      }\n    }\n    return -1;\n  },\n  \n  nth: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    const index = n >= 0 ? n : arr.length + n;\n    return arr[index];\n  },\n  \n  pullAt: function(indexes) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const pulled = [];\n    const indexArr = Array.isArray(indexes) ? indexes : [indexes];\n    \n    // Collect elements at specified indexes\n    for (let i = 0; i < indexArr.length; i++) {\n      const index = indexArr[i];\n      if (index >= 0 && index < arr.length) {\n        pulled.push(arr[index]);\n      }\n    }\n    \n    return new this.constructor(pulled);\n  },\n  \n  reduce: function(iteratee, accumulator) {\n    if (this._value === null || this._value === undefined) {\n      return accumulator;\n    }\n    const arr = Array.from(this._value);\n    let result = accumulator;\n    const startIndex = accumulator !== undefined ? 0 : 1;\n    if (accumulator === undefined && arr.length > 0) {\n      result = arr[0];\n    }\n    for (let i = startIndex; i < arr.length; i++) {\n      result = iteratee(result, arr[i], i, this._value);\n    }\n    return result;\n  },\n  \n  // Lodash specific array methods\n  where: function(properties) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const filtered = [];\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (!item || typeof item !== 'object') continue;\n      let matches = true;\n      for (const [key, val] of Object.entries(properties)) {\n        if (item[key] !== val) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        filtered.push(item);\n      }\n    }\n    return new this.constructor(filtered);\n  },\n  \n  pluck: function(property) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const plucked = [];\n    for (let i = 0; i < arr.length; i++) {\n      plucked.push(arr[i] ? arr[i][property] : undefined);\n    }\n    return new this.constructor(plucked);\n  },\n  \n  sortBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n      sorted.push(arr[i]);\n    }\n    // Simple bubble sort for VM compatibility\n    for (let i = 0; i < sorted.length - 1; i++) {\n      for (let j = 0; j < sorted.length - i - 1; j++) {\n        const aVal = typeof iteratee === 'function' ? iteratee(sorted[j]) : sorted[j][iteratee];\n        const bVal = typeof iteratee === 'function' ? iteratee(sorted[j + 1]) : sorted[j + 1][iteratee];\n        if (aVal > bVal) {\n          const temp = sorted[j];\n          sorted[j] = sorted[j + 1];\n          sorted[j + 1] = temp;\n        }\n      }\n    }\n    return new this.constructor(sorted);\n  },\n  \n  orderBy: function(iteratees, orders) {\n    const iterateeArr = Array.isArray(iteratees) ? iteratees : [iteratees];\n    const orderArr = Array.isArray(orders) ? orders : [orders];\n    \n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n      sorted.push(arr[i]);\n    }\n    \n    // Bubble sort with multiple keys\n    for (let i = 0; i < sorted.length - 1; i++) {\n      for (let j = 0; j < sorted.length - i - 1; j++) {\n        let shouldSwap = false;\n        \n        for (let k = 0; k < iterateeArr.length; k++) {\n          const iteratee = iterateeArr[k];\n          const order = orderArr[k] || 'asc';\n          const aVal = typeof iteratee === 'function' ? iteratee(sorted[j]) : sorted[j][iteratee];\n          const bVal = typeof iteratee === 'function' ? iteratee(sorted[j + 1]) : sorted[j + 1][iteratee];\n          \n          if (aVal < bVal) {\n            shouldSwap = order === 'desc';\n            break;\n          }\n          if (aVal > bVal) {\n            shouldSwap = order === 'asc';\n            break;\n          }\n        }\n        \n        if (shouldSwap) {\n          const temp = sorted[j];\n          sorted[j] = sorted[j + 1];\n          sorted[j + 1] = temp;\n        }\n      }\n    }\n    return new this.constructor(sorted);\n  },\n  \n  groupBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const grouped = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (!grouped[key]) grouped[key] = [];\n      grouped[key].push(item);\n    }\n    return new this.constructor(grouped);\n  },\n  \n  countBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const counted = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      counted[key] = (counted[key] || 0) + 1;\n    }\n    return new this.constructor(counted);\n  },\n  \n  keyBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const keyed = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      keyed[key] = item;\n    }\n    return new this.constructor(keyed);\n  },\n  \n  take: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const taken = [];\n    for (let i = 0; i < Math.min(n, arr.length); i++) {\n      taken.push(arr[i]);\n    }\n    return new this.constructor(taken);\n  },\n  \n  skip: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const skipped = [];\n    for (let i = n; i < arr.length; i++) {\n      skipped.push(arr[i]);\n    }\n    return new this.constructor(skipped);\n  },\n  \n  drop: function(n) {\n    return this.skip(n);\n  },\n  \n  takeWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const taken = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) break;\n      taken.push(arr[i]);\n    }\n    return new this.constructor(taken);\n  },\n  \n  dropWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    let dropIndex = 0;\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) {\n        dropIndex = i;\n        break;\n      }\n    }\n    const result = [];\n    for (let i = dropIndex; i < arr.length; i++) {\n      result.push(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  takeRight: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const startIndex = Math.max(0, arr.length - n);\n    const result = [];\n    for (let i = startIndex; i < arr.length; i++) {\n      result.push(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  takeRightWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (!predicate(arr[i], i, arr)) break;\n      result.unshift(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  dropRight: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const endIndex = Math.max(0, arr.length - n);\n    const result = [];\n    for (let i = 0; i < endIndex; i++) {\n      result.push(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  dropRightWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    let endIndex = arr.length;\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (!predicate(arr[i], i, arr)) {\n        endIndex = i + 1;\n        break;\n      }\n    }\n    const result = [];\n    for (let i = 0; i < endIndex; i++) {\n      result.push(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  uniq: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const unique = [];\n    const seen = {};\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      const key = typeof val === 'object' ? JSON.stringify(val) : String(val);\n      if (!seen[key]) {\n        seen[key] = true;\n        unique.push(val);\n      }\n    }\n    return new this.constructor(unique);\n  },\n  \n  uniqBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const seen = {};\n    const unique = [];\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);\n      if (!seen[keyStr]) {\n        seen[keyStr] = true;\n        unique.push(item);\n      }\n    }\n    return new this.constructor(unique);\n  },\n  \n  sample: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return arr[Math.floor(Math.random() * arr.length)];\n  },\n  \n  sampleSize: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const shuffled = [];\n    for (let i = 0; i < arr.length; i++) {\n      shuffled.push(arr[i]);\n    }\n    // Fisher-Yates shuffle\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n    }\n    const result = [];\n    for (let i = 0; i < Math.min(n, shuffled.length); i++) {\n      result.push(shuffled[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  shuffle: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const shuffled = [];\n    for (let i = 0; i < arr.length; i++) {\n      shuffled.push(arr[i]);\n    }\n    // Fisher-Yates shuffle\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n    }\n    return new this.constructor(shuffled);\n  },\n  \n  flatten: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const flattened = [];\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      if (Array.isArray(val)) {\n        for (let j = 0; j < val.length; j++) {\n          flattened.push(val[j]);\n        }\n      } else {\n        flattened.push(val);\n      }\n    }\n    return new this.constructor(flattened);\n  },\n  \n  flattenDeep: function() {\n    const flattenDeepRecursive = (arr) => {\n      const result = [];\n      for (let i = 0; i < arr.length; i++) {\n        const val = arr[i];\n        if (Array.isArray(val)) {\n          const nested = flattenDeepRecursive(val);\n          for (let j = 0; j < nested.length; j++) {\n            result.push(nested[j]);\n          }\n        } else {\n          result.push(val);\n        }\n      }\n      return result;\n    };\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const flattened = flattenDeepRecursive(Array.from(this._value));\n    return new this.constructor(flattened);\n  },\n  \n  flatMap: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n      const mapped = iteratee(arr[i], i, arr);\n      if (Array.isArray(mapped)) {\n        for (let j = 0; j < mapped.length; j++) {\n          result.push(mapped[j]);\n        }\n      } else {\n        result.push(mapped);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  flatMapDeep: function(iteratee) {\n    const flattenDeepRecursive = (val) => {\n      const result = [];\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          const nested = flattenDeepRecursive(val[i]);\n          for (let j = 0; j < nested.length; j++) {\n            result.push(nested[j]);\n          }\n        }\n      } else {\n        result.push(val);\n      }\n      return result;\n    };\n    \n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n      const mapped = iteratee(arr[i], i, arr);\n      const flattened = flattenDeepRecursive(mapped);\n      for (let j = 0; j < flattened.length; j++) {\n        result.push(flattened[j]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  invokeMap: function(path, ...args) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (typeof path === 'function') {\n        result.push(path.apply(item, args));\n      } else if (item && typeof item[path] === 'function') {\n        result.push(item[path](...args));\n      } else {\n        result.push(undefined);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  partition: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([[], []]);\n    }\n    const arr = Array.from(this._value);\n    const truthy = [];\n    const falsy = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, arr)) {\n        truthy.push(arr[i]);\n      } else {\n        falsy.push(arr[i]);\n      }\n    }\n    return new this.constructor([truthy, falsy]);\n  },\n  \n  compact: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const compacted = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        compacted.push(arr[i]);\n      }\n    }\n    return new this.constructor(compacted);\n  },\n  \n  chunk: function(size) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const chunks = [];\n    for (let i = 0; i < arr.length; i += size) {\n      const chunk = [];\n      for (let j = i; j < Math.min(i + size, arr.length); j++) {\n        chunk.push(arr[j]);\n      }\n      chunks.push(chunk);\n    }\n    return new this.constructor(chunks);\n  },\n  \n  reverse: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const reversed = [];\n    for (let i = arr.length - 1; i >= 0; i--) {\n      reversed.push(arr[i]);\n    }\n    return new this.constructor(reversed);\n  },\n  \n  pullAll: function(values) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n      let shouldInclude = true;\n      for (let j = 0; j < values.length; j++) {\n        if (arr[i] === values[j]) {\n          shouldInclude = false;\n          break;\n        }\n      }\n      if (shouldInclude) {\n        result.push(arr[i]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  pullAllBy: function(values, iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    const valueKeys = [];\n    for (let i = 0; i < values.length; i++) {\n      const key = typeof iteratee === 'function' ? iteratee(values[i]) : values[i][iteratee];\n      valueKeys.push(key);\n    }\n    \n    for (let i = 0; i < arr.length; i++) {\n      const itemKey = typeof iteratee === 'function' ? iteratee(arr[i]) : arr[i][iteratee];\n      let shouldInclude = true;\n      for (let j = 0; j < valueKeys.length; j++) {\n        if (itemKey === valueKeys[j]) {\n          shouldInclude = false;\n          break;\n        }\n      }\n      if (shouldInclude) {\n        result.push(arr[i]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  differenceBy: function(values, iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    const valueKeys = [];\n    for (let i = 0; i < values.length; i++) {\n      const key = typeof iteratee === 'function' ? iteratee(values[i]) : values[i][iteratee];\n      valueKeys.push(key);\n    }\n    \n    for (let i = 0; i < arr.length; i++) {\n      const itemKey = typeof iteratee === 'function' ? iteratee(arr[i]) : arr[i][iteratee];\n      let shouldInclude = true;\n      for (let j = 0; j < valueKeys.length; j++) {\n        if (itemKey === valueKeys[j]) {\n          shouldInclude = false;\n          break;\n        }\n      }\n      if (shouldInclude) {\n        result.push(arr[i]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  differenceWith: function(values, comparator) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    \n    for (let i = 0; i < arr.length; i++) {\n      let shouldInclude = true;\n      for (let j = 0; j < values.length; j++) {\n        if (comparator(arr[i], values[j])) {\n          shouldInclude = false;\n          break;\n        }\n      }\n      if (shouldInclude) {\n        result.push(arr[i]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  intersectionBy: function(values, iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    const seen = {};\n    \n    for (let i = 0; i < arr.length; i++) {\n      const itemKey = typeof iteratee === 'function' ? iteratee(arr[i]) : arr[i][iteratee];\n      const keyStr = typeof itemKey === 'object' ? JSON.stringify(itemKey) : String(itemKey);\n      \n      for (let j = 0; j < values.length; j++) {\n        const valueKey = typeof iteratee === 'function' ? iteratee(values[j]) : values[j][iteratee];\n        const valueKeyStr = typeof valueKey === 'object' ? JSON.stringify(valueKey) : String(valueKey);\n        \n        if (keyStr === valueKeyStr && !seen[keyStr]) {\n          seen[keyStr] = true;\n          result.push(arr[i]);\n          break;\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  intersectionWith: function(values, comparator) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    \n    for (let i = 0; i < arr.length; i++) {\n      for (let j = 0; j < values.length; j++) {\n        if (comparator(arr[i], values[j])) {\n          result.push(arr[i]);\n          break;\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  unionBy: function(arrays, iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    const seen = {};\n    \n    // Process first array\n    for (let i = 0; i < arr.length; i++) {\n      const key = typeof iteratee === 'function' ? iteratee(arr[i]) : arr[i][iteratee];\n      const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);\n      if (!seen[keyStr]) {\n        seen[keyStr] = true;\n        result.push(arr[i]);\n      }\n    }\n    \n    // Process additional arrays\n    for (let i = 0; i < arrays.length; i++) {\n      const key = typeof iteratee === 'function' ? iteratee(arrays[i]) : arrays[i][iteratee];\n      const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);\n      if (!seen[keyStr]) {\n        seen[keyStr] = true;\n        result.push(arrays[i]);\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  unionWith: function(arrays, comparator) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const result = [];\n    \n    // Add all items from first array\n    for (let i = 0; i < arr.length; i++) {\n      result.push(arr[i]);\n    }\n    \n    // Add items from additional arrays if not already present\n    for (let i = 0; i < arrays.length; i++) {\n      let shouldAdd = true;\n      for (let j = 0; j < result.length; j++) {\n        if (comparator(arrays[i], result[j])) {\n          shouldAdd = false;\n          break;\n        }\n      }\n      if (shouldAdd) {\n        result.push(arrays[i]);\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  xor: function(...arrays) {\n    const allArrays = [this._value || []].concat(arrays);\n    const result = [];\n    const counts = {};\n    \n    // Count occurrences\n    for (let i = 0; i < allArrays.length; i++) {\n      const arr = Array.from(allArrays[i]);\n      const seen = {};\n      for (let j = 0; j < arr.length; j++) {\n        const key = typeof arr[j] === 'object' ? JSON.stringify(arr[j]) : String(arr[j]);\n        if (!seen[key]) {\n          seen[key] = true;\n          counts[key] = (counts[key] || 0) + 1;\n        }\n      }\n    }\n    \n    // Add items that appear in exactly one array\n    for (let i = 0; i < allArrays.length; i++) {\n      const arr = Array.from(allArrays[i]);\n      for (let j = 0; j < arr.length; j++) {\n        const key = typeof arr[j] === 'object' ? JSON.stringify(arr[j]) : String(arr[j]);\n        if (counts[key] === 1) {\n          counts[key] = -1; // Mark as added\n          result.push(arr[j]);\n        }\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  xorBy: function(arrays, iteratee) {\n    const allArrays = [this._value || [], arrays];\n    const result = [];\n    const counts = {};\n    const items = {};\n    \n    // Count occurrences by key\n    for (let i = 0; i < allArrays.length; i++) {\n      const arr = Array.from(allArrays[i]);\n      const seen = {};\n      for (let j = 0; j < arr.length; j++) {\n        const key = typeof iteratee === 'function' ? iteratee(arr[j]) : arr[j][iteratee];\n        const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);\n        if (!seen[keyStr]) {\n          seen[keyStr] = true;\n          counts[keyStr] = (counts[keyStr] || 0) + 1;\n          if (!items[keyStr]) {\n            items[keyStr] = arr[j];\n          }\n        }\n      }\n    }\n    \n    // Add items that appear in exactly one array\n    for (const keyStr in counts) {\n      if (counts[keyStr] === 1) {\n        result.push(items[keyStr]);\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  xorWith: function(arrays, comparator) {\n    const allArrays = [this._value || [], arrays];\n    const result = [];\n    \n    for (let i = 0; i < allArrays.length; i++) {\n      const arr = Array.from(allArrays[i]);\n      for (let j = 0; j < arr.length; j++) {\n        let count = 0;\n        \n        // Count how many arrays contain this item\n        for (let k = 0; k < allArrays.length; k++) {\n          const otherArr = Array.from(allArrays[k]);\n          for (let l = 0; l < otherArr.length; l++) {\n            if (comparator(arr[j], otherArr[l])) {\n              count++;\n              break;\n            }\n          }\n        }\n        \n        // Add if appears in exactly one array and not already in result\n        if (count === 1) {\n          let alreadyAdded = false;\n          for (let k = 0; k < result.length; k++) {\n            if (comparator(arr[j], result[k])) {\n              alreadyAdded = true;\n              break;\n            }\n          }\n          if (!alreadyAdded) {\n            result.push(arr[j]);\n          }\n        }\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  // Math methods\n  sum: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return 0;\n    }\n    const arr = Array.from(this._value);\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      let num;\n      if (iteratee && typeof iteratee === 'string') {\n        num = Number(val?.[iteratee]) || 0;\n      } else if (iteratee && typeof iteratee === 'function') {\n        num = Number(iteratee(val)) || 0;\n      } else {\n        num = Number(val) || 0;\n      }\n      sum += num;\n    }\n    return sum;\n  },\n  \n  sumBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return 0;\n    }\n    const arr = Array.from(this._value);\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      let num;\n      if (typeof iteratee === 'string') {\n        num = Number(val?.[iteratee]) || 0;\n      } else if (typeof iteratee === 'function') {\n        num = Number(iteratee(val)) || 0;\n      } else {\n        num = Number(val) || 0;\n      }\n      sum += num;\n    }\n    return sum;\n  },\n  \n  mean: function() {\n    if (this._value === null || this._value === undefined) {\n      return NaN;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return NaN;\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += Number(arr[i]) || 0;\n    }\n    return sum / arr.length;\n  },\n  \n  meanBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return NaN;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return NaN;\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      let num;\n      if (typeof iteratee === 'string') {\n        num = Number(val?.[iteratee]) || 0;\n      } else if (typeof iteratee === 'function') {\n        num = Number(iteratee(val)) || 0;\n      } else {\n        num = Number(val) || 0;\n      }\n      sum += num;\n    }\n    return sum / arr.length;\n  },\n  \n  add: function(addend) {\n    const augend = Number(this._value) || 0;\n    return augend + (Number(addend) || 0);\n  },\n  \n  subtract: function(subtrahend) {\n    const minuend = Number(this._value) || 0;\n    return minuend - (Number(subtrahend) || 0);\n  },\n  \n  multiply: function(multiplicand) {\n    const multiplier = Number(this._value) || 0;\n    return multiplier * (Number(multiplicand) || 0);\n  },\n  \n  divide: function(divisor) {\n    const dividend = Number(this._value) || 0;\n    return dividend / (Number(divisor) || 1);\n  },\n  \n  ceil: function(precision) {\n    const num = Number(this._value) || 0;\n    precision = precision || 0;\n    const factor = Math.pow(10, precision);\n    return Math.ceil(num * factor) / factor;\n  },\n  \n  floor: function(precision) {\n    const num = Number(this._value) || 0;\n    precision = precision || 0;\n    const factor = Math.pow(10, precision);\n    return Math.floor(num * factor) / factor;\n  },\n  \n  round: function(precision) {\n    const num = Number(this._value) || 0;\n    precision = precision || 0;\n    const factor = Math.pow(10, precision);\n    return Math.round(num * factor) / factor;\n  },\n  \n  min: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let min = Number(arr[0]) || 0;\n    for (let i = 1; i < arr.length; i++) {\n      const num = Number(arr[i]) || 0;\n      if (num < min) min = num;\n    }\n    return min;\n  },\n  \n  max: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let max = Number(arr[0]) || 0;\n    for (let i = 1; i < arr.length; i++) {\n      const num = Number(arr[i]) || 0;\n      if (num > max) max = num;\n    }\n    return max;\n  },\n  \n  minBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let min = arr[0];\n    let minVal = typeof iteratee === 'function' ? iteratee(min) : min[iteratee];\n    for (let i = 1; i < arr.length; i++) {\n      const item = arr[i];\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (itemVal < minVal) {\n        min = item;\n        minVal = itemVal;\n      }\n    }\n    return min;\n  },\n  \n  maxBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let max = arr[0];\n    let maxVal = typeof iteratee === 'function' ? iteratee(max) : max[iteratee];\n    for (let i = 1; i < arr.length; i++) {\n      const item = arr[i];\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (itemVal > maxVal) {\n        max = item;\n        maxVal = itemVal;\n      }\n    }\n    return max;\n  },\n  \n  // Object methods\n  pick: function(...args) {\n    const result = {};\n    const obj = this._value;\n    // Support both array syntax and spread syntax\n    const keys = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;\n    if (obj && typeof obj === 'object') {\n      for (const key of keys) {\n        if (key in obj) {\n          result[key] = obj[key];\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  omit: function(...args) {\n    const result = {};\n    const obj = this._value;\n    // Support both array syntax and spread syntax\n    const keys = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;\n    if (obj && typeof obj === 'object') {\n      for (const key in obj) {\n        if (!keys.includes(key)) {\n          result[key] = obj[key];\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  keys: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.keys(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  values: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.values(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  entries: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.entries(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  fromPairs: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const pairs = Array.from(this._value);\n    const result = {};\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (Array.isArray(pair) && pair.length >= 2) {\n        result[pair[0]] = pair[1];\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  zipObject: function(values) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const keys = Array.from(this._value);\n    const vals = values || [];\n    const result = {};\n    for (let i = 0; i < keys.length; i++) {\n      result[keys[i]] = vals[i];\n    }\n    return new this.constructor(result);\n  },\n  \n  zipObjectDeep: function(values) {\n    const setDeep = (obj, path, value) => {\n      const keys = path.split('.');\n      let current = obj;\n      for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (!current[key] || typeof current[key] !== 'object') {\n          current[key] = {};\n        }\n        current = current[key];\n      }\n      current[keys[keys.length - 1]] = value;\n    };\n    \n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const paths = Array.from(this._value);\n    const vals = values || [];\n    const result = {};\n    for (let i = 0; i < paths.length; i++) {\n      setDeep(result, paths[i], vals[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  unzip: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arrays = Array.from(this._value);\n    if (arrays.length === 0) return new this.constructor([]);\n    \n    const result = [];\n    const maxLength = Math.max(...arrays.map(arr => arr ? arr.length : 0));\n    \n    for (let i = 0; i < maxLength; i++) {\n      const group = [];\n      for (let j = 0; j < arrays.length; j++) {\n        group.push(arrays[j] ? arrays[j][i] : undefined);\n      }\n      result.push(group);\n    }\n    return new this.constructor(result);\n  },\n  \n  unzipWith: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arrays = Array.from(this._value);\n    if (arrays.length === 0) return new this.constructor([]);\n    \n    const result = [];\n    const maxLength = Math.max(...arrays.map(arr => arr ? arr.length : 0));\n    \n    for (let i = 0; i < maxLength; i++) {\n      const group = [];\n      for (let j = 0; j < arrays.length; j++) {\n        group.push(arrays[j] ? arrays[j][i] : undefined);\n      }\n      result.push(iteratee(...group));\n    }\n    return new this.constructor(result);\n  },\n  \n  invert: function() {\n    const result = {};\n    const obj = this._value;\n    if (obj && typeof obj === 'object') {\n      for (const [key, value] of Object.entries(obj)) {\n        result[String(value)] = key;\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  merge: function(...sources) {\n    const merged = Object.assign({}, this._value, ...sources);\n    return new this.constructor(merged);\n  },\n  \n  defaults: function(...sources) {\n    const result = { ...this._value };\n    for (const source of sources) {\n      if (source && typeof source === 'object') {\n        for (const [key, value] of Object.entries(source)) {\n          if (!(key in result)) {\n            result[key] = value;\n          }\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  get: function(path, defaultValue) {\n    const pathArray = Array.isArray(path) ? path : path.split('.');\n    let current = this._value;\n    \n    for (let i = 0; i < pathArray.length; i++) {\n      if (current === null || current === undefined || typeof current !== 'object') {\n        return defaultValue;\n      }\n      current = current[pathArray[i]];\n    }\n    \n    return current === undefined ? defaultValue : current;\n  },\n  \n  set: function(path, value) {\n    const pathArray = Array.isArray(path) ? path : path.split('.');\n    const obj = this._value && typeof this._value === 'object' ? { ...this._value } : {};\n    let current = obj;\n    \n    for (let i = 0; i < pathArray.length - 1; i++) {\n      const key = pathArray[i];\n      if (!current[key] || typeof current[key] !== 'object') {\n        current[key] = {};\n      }\n      current = current[key];\n    }\n    \n    current[pathArray[pathArray.length - 1]] = value;\n    return new this.constructor(obj);\n  },\n  \n  has: function(path) {\n    const pathArray = Array.isArray(path) ? path : path.split('.');\n    let current = this._value;\n    \n    for (let i = 0; i < pathArray.length; i++) {\n      if (current === null || current === undefined || typeof current !== 'object') {\n        return false;\n      }\n      if (!(pathArray[i] in current)) {\n        return false;\n      }\n      current = current[pathArray[i]];\n    }\n    \n    return true;\n  },\n  \n  hasIn: function(path) {\n    const pathArray = Array.isArray(path) ? path : path.split('.');\n    let current = this._value;\n    \n    for (let i = 0; i < pathArray.length; i++) {\n      if (current === null || current === undefined) {\n        return false;\n      }\n      if (!(pathArray[i] in current)) {\n        return false;\n      }\n      current = current[pathArray[i]];\n    }\n    \n    return true;\n  },\n  \n  mapKeys: function(iteratee) {\n    const result = {};\n    const obj = this._value;\n    \n    if (obj && typeof obj === 'object') {\n      for (const [key, value] of Object.entries(obj)) {\n        const newKey = typeof iteratee === 'function' ? iteratee(value, key, obj) : value[iteratee];\n        result[newKey] = value;\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  mapValues: function(iteratee) {\n    const result = {};\n    const obj = this._value;\n    \n    if (obj && typeof obj === 'object') {\n      for (const [key, value] of Object.entries(obj)) {\n        result[key] = typeof iteratee === 'function' ? iteratee(value, key, obj) : value[iteratee];\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  toPairs: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.entries(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  toPairsIn: function() {\n    const result = [];\n    if (this._value && typeof this._value === 'object') {\n      for (const key in this._value) {\n        result.push([key, this._value[key]]);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  assignIn: function(...sources) {\n    const result = {};\n    const objects = [this._value, ...sources];\n    \n    for (const obj of objects) {\n      if (obj && typeof obj === 'object') {\n        for (const key in obj) {\n          result[key] = obj[key];\n        }\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  assignWith: function(...args) {\n    // Extract customizer (last argument if it's a function)\n    const customizer = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n    const sources = args;\n    \n    const result = { ...this._value };\n    \n    for (const source of sources) {\n      if (source && typeof source === 'object') {\n        for (const [key, value] of Object.entries(source)) {\n          if (customizer) {\n            const customized = customizer(result[key], value, key, result, source);\n            result[key] = customized !== undefined ? customized : value;\n          } else {\n            result[key] = value;\n          }\n        }\n      }\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  mergeWith: function(customizer, ...sources) {\n    const deepMergeWithCustomizer = (target, source, customizer, key) => {\n      const customized = customizer(target, source, key);\n      if (customized !== undefined) {\n        return customized;\n      }\n      \n      if (typeof target === 'object' && typeof source === 'object' && target !== null && source !== null) {\n        const result = Array.isArray(target) ? [...target] : { ...target };\n        for (const k in source) {\n          result[k] = deepMergeWithCustomizer(result[k], source[k], customizer, k);\n        }\n        return result;\n      }\n      \n      return source;\n    };\n    \n    let result = this._value;\n    for (const source of sources) {\n      result = deepMergeWithCustomizer(result, source, customizer);\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  at: function(...paths) {\n    const result = [];\n    const flatPaths = paths.flat();\n    \n    for (const path of flatPaths) {\n      const pathArray = Array.isArray(path) ? path : path.split('.');\n      let current = this._value;\n      \n      for (let i = 0; i < pathArray.length; i++) {\n        if (current === null || current === undefined || typeof current !== 'object') {\n          current = undefined;\n          break;\n        }\n        current = current[pathArray[i]];\n      }\n      \n      result.push(current);\n    }\n    \n    return new this.constructor(result);\n  },\n  \n  // String methods\n  camelCase: function() {\n    const str = String(this._value);\n    const camelCased = str\n      .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())\n      .replace(/^./, chr => chr.toLowerCase());\n    return new this.constructor(camelCased);\n  },\n  \n  kebabCase: function() {\n    const str = String(this._value);\n    // Simpler approach: insert hyphen before any capital letter that follows a lowercase or digit\n    let result = str\n    .replace(/([a-z])([A-Z])/g, '$1-$2') // Add hyphen between lower/uppercase\n    .replace(/[\\s_]+/g, '-')             // Replace spaces/underscores with hyphen\n    .toLowerCase();\n      \n    return new this.constructor(result);\n  },\n  \n  snakeCase: function() {\n    const str = String(this._value);\n    const result = str && str\n    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n    .map(s => s.toLowerCase())\n    .join('_');\n      \n    return new this.constructor(result);\n  },\n  \n  startCase: function() {\n    const str = String(this._value);\n    const startCased = str\n      .replace(/([a-z])([A-Z])/g, '$1 $2')\n      .replace(/[_-]+/g, ' ')\n      .split(' ')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n    return new this.constructor(startCased);\n  },\n  \n  upperFirst: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toUpperCase() + str.slice(1));\n  },\n  \n  lowerFirst: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toLowerCase() + str.slice(1));\n  },\n  \n  capitalize: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toUpperCase() + str.slice(1).toLowerCase());\n  },\n  \n  upperCase: function() {\n    const str = String(this._value);\n    const words = str.match(/[A-Za-z][a-z]*|[0-9]+|[A-Z]+(?=[A-Z][a-z]|\b)/g) || [];\n    return new this.constructor(words.map(word => word.toUpperCase()).join(' '));\n  },\n  \n  lowerCase: function() {\n    const str = String(this._value);\n    const words = str.match(/[A-Za-z][a-z]*|[0-9]+|[A-Z]+(?=[A-Z][a-z]|\b)/g) || [];\n    return new this.constructor(words.map(word => word.toLowerCase()).join(' '));\n  },\n  \n  pad: function(length, chars) {\n    const str = String(this._value);\n    const padChars = chars || ' ';\n    const targetLength = Number(length) || 0;\n    \n    if (str.length >= targetLength) {\n      return new this.constructor(str);\n    }\n    \n    const totalPadding = targetLength - str.length;\n    const leftPadding = Math.floor(totalPadding / 2);\n    const rightPadding = totalPadding - leftPadding;\n    \n    let leftPad = '';\n    let rightPad = '';\n    \n    // Build left padding\n    while (leftPad.length < leftPadding) {\n      leftPad += padChars;\n    }\n    leftPad = leftPad.slice(0, leftPadding);\n    \n    // Build right padding\n    while (rightPad.length < rightPadding) {\n      rightPad += padChars;\n    }\n    rightPad = rightPad.slice(0, rightPadding);\n    \n    return new this.constructor(leftPad + str + rightPad);\n  },\n  \n  padStart: function(length, chars) {\n    const str = String(this._value);\n    const padChars = chars || ' ';\n    const targetLength = Number(length) || 0;\n    \n    if (str.length >= targetLength) {\n      return new this.constructor(str);\n    }\n    \n    const paddingLength = targetLength - str.length;\n    let padding = '';\n    \n    while (padding.length < paddingLength) {\n      padding += padChars;\n    }\n    padding = padding.slice(0, paddingLength);\n    \n    return new this.constructor(padding + str);\n  },\n  \n  padEnd: function(length, chars) {\n    const str = String(this._value);\n    const padChars = chars || ' ';\n    const targetLength = Number(length) || 0;\n    \n    if (str.length >= targetLength) {\n      return new this.constructor(str);\n    }\n    \n    const paddingLength = targetLength - str.length;\n    let padding = '';\n    \n    while (padding.length < paddingLength) {\n      padding += padChars;\n    }\n    padding = padding.slice(0, paddingLength);\n    \n    return new this.constructor(str + padding);\n  },\n  \n  trim: function(chars) {\n    const str = String(this._value);\n    if (!chars) {\n      return new this.constructor(str.trim());\n    }\n    \n    const charSet = chars.split('');\n    let start = 0;\n    let end = str.length;\n    \n    // Trim from start\n    while (start < str.length && charSet.includes(str[start])) {\n      start++;\n    }\n    \n    // Trim from end\n    while (end > start && charSet.includes(str[end - 1])) {\n      end--;\n    }\n    \n    return new this.constructor(str.slice(start, end));\n  },\n  \n  trimStart: function(chars) {\n    const str = String(this._value);\n    if (!chars) {\n      return new this.constructor(str.trimStart());\n    }\n    \n    const charSet = chars.split('');\n    let start = 0;\n    \n    while (start < str.length && charSet.includes(str[start])) {\n      start++;\n    }\n    \n    return new this.constructor(str.slice(start));\n  },\n  \n  trimEnd: function(chars) {\n    const str = String(this._value);\n    if (!chars) {\n      return new this.constructor(str.trimEnd());\n    }\n    \n    const charSet = chars.split('');\n    let end = str.length;\n    \n    while (end > 0 && charSet.includes(str[end - 1])) {\n      end--;\n    }\n    \n    return new this.constructor(str.slice(0, end));\n  },\n  \n  truncate: function(options) {\n    const str = String(this._value);\n    const opts = options || {};\n    const length = opts.length || 30;\n    const omission = opts.omission || '...';\n    const separator = opts.separator;\n    \n    if (str.length <= length) {\n      return new this.constructor(str);\n    }\n    \n    let end = length - omission.length;\n    if (end < 1) {\n      return new this.constructor(omission);\n    }\n    \n    let result = str.slice(0, end);\n    \n    if (separator) {\n      const sepRegex = typeof separator === 'string' ? new RegExp(separator, 'g') : separator;\n      let lastMatch = null;\n      let match;\n      \n      while ((match = sepRegex.exec(result)) !== null) {\n        lastMatch = match.index;\n      }\n      \n      if (lastMatch !== null) {\n        result = result.slice(0, lastMatch);\n      }\n    }\n    \n    return new this.constructor(result + omission);\n  },\n  \n  escape: function() {\n    const str = String(this._value);\n    const htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n    \n    return new this.constructor(str.replace(/[&<>\"']/g, match => htmlEscapes[match]));\n  },\n  \n  unescape: function() {\n    const str = String(this._value);\n    const htmlUnescapes = {\n      '&amp;': '&',\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&#39;': \"'\"\n    };\n    \n    return new this.constructor(str.replace(/&(?:amp|lt|gt|quot|#39);/g, match => htmlUnescapes[match]));\n  },\n  \n  words: function(pattern) {\n    const str = String(this._value);\n    const regex = pattern || /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;\n    return new this.constructor(str.match(regex) || []);\n  },\n  \n  deburr: function() {\n    const str = String(this._value);\n    const deburredLetters = {\n      'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A',\n      'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a',\n      'Ç': 'C', 'ç': 'c',\n      'Ð': 'D', 'ð': 'd',\n      'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E',\n      'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e',\n      'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I',\n      'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i',\n      'Ñ': 'N', 'ñ': 'n',\n      'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'O', 'Ø': 'O',\n      'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o', 'ø': 'o',\n      'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'U',\n      'ù': 'u', 'ú': 'u', 'û': 'u', 'ü': 'u',\n      'Ý': 'Y', 'ý': 'y', 'ÿ': 'y',\n      'Æ': 'Ae', 'æ': 'ae',\n      'Þ': 'Th', 'þ': 'th',\n      'ß': 'ss'\n    };\n    \n    return new this.constructor(str.replace(/[À-ÿ]/g, match => deburredLetters[match] || match));\n  },\n  \n  // Utility methods\n  size: function() {\n    if (Array.isArray(this._value) || typeof this._value === 'string') {\n      return this._value.length;\n    }\n    if (this._value && typeof this._value === 'object') {\n      return Object.keys(this._value).length;\n    }\n    return 0;\n  },\n  \n  isEmpty: function() {\n    if (this._value === null || this._value === undefined) return true;\n    if (Array.isArray(this._value)) return this._value.length === 0;\n    if (typeof this._value === 'string') return this._value.length === 0;\n    if (typeof this._value === 'object') return Object.keys(this._value).length === 0;\n    return false;\n  },\n  \n  includes: function(value, fromIndex) {\n    if (Array.isArray(this._value)) {\n      return this._value.includes(value, fromIndex);\n    }\n    if (typeof this._value === 'string' && typeof value === 'string') {\n      return this._value.includes(value, fromIndex);\n    }\n    if (this._value && typeof this._value === 'object') {\n      return Object.values(this._value).includes(value);\n    }\n    return false;\n  },\n  \n  // Function utilities\n  identity: function() {\n    return this._value;\n  },\n  \n  constant: function() {\n    const val = this._value;\n    return function() { return val; };\n  },\n  \n  times: function(iteratee) {\n    const n = Number(this._value) || 0;\n    const results = [];\n    for (let i = 0; i < n; i++) {\n      results.push(iteratee(i));\n    }\n    return new this.constructor(results);\n  },\n  \n  range: function(end, step) {\n    const start = Number(this._value) || 0;\n    const endNum = end !== undefined ? Number(end) : start;\n    const startNum = end !== undefined ? start : 0;\n    const stepNum = step || (startNum < endNum ? 1 : -1);\n    \n    const result = [];\n    if (stepNum > 0) {\n      for (let i = startNum; i < endNum; i += stepNum) {\n        result.push(i);\n      }\n    } else {\n      for (let i = startNum; i > endNum; i += stepNum) {\n        result.push(i);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  clamp: function(lower, upper) {\n    const num = Number(this._value) || 0;\n    return Math.max(lower, Math.min(upper, num));\n  },\n  \n  random: function(upper, floating) {\n    const lower = Number(this._value) || 0;\n    const upperNum = upper !== undefined ? Number(upper) : 1;\n    \n    if (floating || lower % 1 || upperNum % 1) {\n      const rand = Math.random();\n      return lower + rand * (upperNum - lower);\n    }\n    return lower + Math.floor(Math.random() * (upperNum - lower + 1));\n  },\n  \n  // Chain\n  chain: function() {\n    // Return this for chaining\n    return this;\n  },\n  \n  value: function() {\n    // Also update public value property for VM unwrapping\n    this.value = this._value;\n    return this._value;\n  },\n  \n  valueOf: function() {\n    return this._value;\n  },\n  \n  // Function utilities\n  debounce: function(wait, options) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    wait = Number(wait) || 0;\n    const opts = options || {};\n    const leading = !!opts.leading;\n    const trailing = opts.trailing !== false;\n    const maxing = 'maxWait' in opts;\n    const maxWait = maxing ? Math.max(Number(opts.maxWait) || 0, wait) : null;\n    \n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let timerId;\n    let lastArgs;\n    let lastThis;\n    let result;\n    \n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      \n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n    \n    function leadingEdge(time) {\n      lastInvokeTime = time;\n      timerId = setTimeout(timerExpired, wait);\n      return leading ? invokeFunc(time) : result;\n    }\n    \n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      const timeWaiting = wait - timeSinceLastCall;\n      \n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n    \n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      \n      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    \n    function timerExpired() {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    \n    function trailingEdge(time) {\n      timerId = undefined;\n      \n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n    \n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    \n    function flush() {\n      return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    \n    function debounced() {\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n      \n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n      \n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        if (maxing) {\n          clearTimeout(timerId);\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n      return result;\n    }\n    \n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  },\n  \n  throttle: function(wait, options) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const leading = options && options.leading !== false;\n    const trailing = options && options.trailing !== false;\n    \n    return this.debounce(wait, {\n      leading: leading,\n      maxWait: wait,\n      trailing: trailing\n    });\n  },\n  \n  curry: function(arity) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const n = arity !== undefined ? arity : func.length;\n    \n    function curried() {\n      const args = Array.from(arguments);\n      if (args.length >= n) {\n        return func.apply(this, args);\n      }\n      return function() {\n        return curried.apply(this, args.concat(Array.from(arguments)));\n      };\n    }\n    \n    return curried;\n  },\n  \n  curryRight: function(arity) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const n = arity !== undefined ? arity : func.length;\n    \n    function curried() {\n      const args = Array.from(arguments);\n      if (args.length >= n) {\n        return func.apply(this, args);\n      }\n      return function() {\n        return curried.apply(this, Array.from(arguments).concat(args));\n      };\n    }\n    \n    return curried;\n  },\n  \n  partial: function(...partials) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    return function() {\n      const args = [];\n      let partialIndex = 0;\n      let argIndex = 0;\n      \n      for (let i = 0; i < partials.length; i++) {\n        args.push(partials[i]);\n      }\n      \n      for (let i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n      \n      return func.apply(this, args);\n    };\n  },\n  \n  partialRight: function(...partials) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    return function() {\n      const args = Array.from(arguments);\n      for (let i = 0; i < partials.length; i++) {\n        args.push(partials[i]);\n      }\n      return func.apply(this, args);\n    };\n  },\n  \n  memoize: function(resolver) {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const memoized = function() {\n      const key = resolver ? resolver.apply(this, arguments) : arguments[0];\n      const cache = memoized.cache;\n      \n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      const result = func.apply(this, arguments);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n    \n    memoized.cache = new Map();\n    return memoized;\n  },\n  \n  once: function() {\n    const func = this._value;\n    if (typeof func !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    let called = false;\n    let result;\n    \n    return function() {\n      if (!called) {\n        called = true;\n        result = func.apply(this, arguments);\n      }\n      return result;\n    };\n  },\n  \n  flow: function(...funcs) {\n    const firstFunc = this._value;\n    if (typeof firstFunc !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const allFuncs = [firstFunc, ...funcs];\n    \n    return function() {\n      let result = allFuncs[0].apply(this, arguments);\n      for (let i = 1; i < allFuncs.length; i++) {\n        result = allFuncs[i].call(this, result);\n      }\n      return result;\n    };\n  },\n  \n  flowRight: function(...funcs) {\n    const lastFunc = this._value;\n    if (typeof lastFunc !== 'function') {\n      throw new TypeError('Expected a function');\n    }\n    \n    const allFuncs = [...funcs, lastFunc];\n    \n    return function() {\n      let result = allFuncs[allFuncs.length - 1].apply(this, arguments);\n      for (let i = allFuncs.length - 2; i >= 0; i--) {\n        result = allFuncs[i].call(this, result);\n      }\n      return result;\n    };\n  }\n};\n"},226:(n,t,e)=>{e.r(t),e.d(t,{ExpressionEvaluator:()=>k});var r=e(248),i=e.n(r);class a{static formatError(n,t){const e=a.getTypeLabel(n.type),r=n.detail?` (${n.detail})`:"",s=n.position?` at line ${n.position.line}:${n.position.column}`:"";return i().bold.red(`${e}: ${n.message}${r}${s}`)}static getTypeLabel(n){switch(n){case"syntax":return"SYNTAX ERROR";case"security":return"SECURITY ERROR";case"runtime":return"RUNTIME ERROR"}}static parseJSONError(n,t){const e=n.message,r=e.match(/at position (\d+)/),i=e.match(/Unexpected token (.) in JSON at position (\d+)/),s=e.match(/Unexpected end of JSON input/);let o,u;if(r||i){const n=i?i[2]:r?.[1];if(n){const e=parseInt(n,10);if(o=a.calculatePosition(t,e),i){const n=i[1];n&&(u=a.getJSONSuggestion(n,t,e))}}}else s&&(o=a.calculatePosition(t,t.length),u="JSON input ended unexpectedly. Check for missing closing brackets or quotes.");return{type:"syntax",message:"Invalid JSON syntax",detail:e,position:o,suggestion:u}}static parseSecurityError(n,t){let e,r,i=null;for(const e of n){const n=t.indexOf(e);-1!==n&&(!i||n<i.index)&&(i={pattern:e,index:n})}return i&&(e=a.calculatePosition(t,i.index),e.length=i.pattern.length,r=a.getSecuritySuggestion(i.pattern)),{type:"security",message:"Expression contains potentially dangerous patterns",detail:`Found dangerous patterns: ${n.join(", ")}`,position:e,suggestion:r}}static parseExpressionError(n,t){const e=n.message,r=e.match(/Unexpected token '?(.+?)'?/);let i,s;if(e.match(/Missing (.+?) after/),r){const n=r[1];if(n){const e=t.indexOf(n);-1!==e&&(i=a.calculatePosition(t,e),i.length=n.length)}s=a.getExpressionSuggestion(e)}return{type:"syntax",message:"Invalid expression syntax",detail:e,position:i,suggestion:s}}static calculatePosition(n,t){let e=1,r=1;for(let i=0;i<Math.min(t,n.length);i++)"\n"===n[i]?(e++,r=1):r++;return{line:e,column:r}}static getJSONSuggestion(n,t,e){switch(n){case"'":return"Single quotes are not valid in JSON. Use double quotes instead.";case",":return e===t.length-1||"}"===t[e+1]||"]"===t[e+1]?"Trailing commas are not allowed in JSON.":"Check for missing values or extra commas.";case"}":case"]":return"Unexpected closing bracket. Check for matching opening brackets.";default:return"Check JSON syntax near this position."}}static getSecuritySuggestion(n){return{eval:"Use a safer alternative like JSON.parse() or a sandboxed evaluator.",Function:"Dynamic function creation is dangerous. Consider using predefined functions.",require:"Dynamic imports are not allowed. Use static imports or predefined modules.",import:"Dynamic imports are not allowed. Use static imports or predefined modules.",process:"Access to process object is restricted for security reasons.",global:"Access to global scope is restricted. Use the provided context.",__dirname:"File system access is not allowed in expressions.",__filename:"File system access is not allowed in expressions.","while(true)":"Infinite loops are not allowed. Use finite iterations.","for(;;)":"Infinite loops are not allowed. Use finite iterations.",readFile:"File system operations are not allowed in expressions.",writeFile:"File system operations are not allowed in expressions.",exec:"Shell command execution is not allowed for security reasons.",spawn:"Process spawning is not allowed for security reasons.",fetch:"Network requests are not allowed in expressions.",setTimeout:"Asynchronous operations are restricted. Use synchronous alternatives.",setInterval:"Asynchronous operations are restricted. Use synchronous alternatives.",Buffer:"Buffer operations are restricted for security reasons."}[n]||"This pattern is restricted for security reasons."}static getExpressionSuggestion(n){return n.includes("Unexpected token")?"Check for syntax errors like missing operators, brackets, or quotes.":n.includes("is not defined")?"The variable or function is not available in the expression context.":n.includes("Cannot read property")?"Trying to access a property of null or undefined. Add null checks.":"Review the expression syntax and ensure all variables are properly defined."}}const s=e(201).v.match(/globalThis\.lodashMethods = ({[\s\S]*});/);if(!s||!s[1])throw new Error("Failed to extract methods from LODASH_METHODS");const o=s[1],u=new Function(`return ${o}`)();class l{constructor(n){this._value=n,this.__isLodash=!0}get length(){return Array.isArray(this._value)||"string"==typeof this._value?this._value.length:this._value&&"object"==typeof this._value?Object.keys(this._value).length:0}[Symbol.iterator](){return null===this._value||void 0===this._value?[][Symbol.iterator]():Array.isArray(this._value)||"string"==typeof this._value?this._value[Symbol.iterator]():this._value&&"object"==typeof this._value?Object.entries(this._value)[Symbol.iterator]():[][Symbol.iterator]()}toJSON(){return this._value}valueOf(){return this._value}toString(){return null===this._value?"null":void 0===this._value?"undefined":String(this._value)}[Symbol.toPrimitive](n){return"string"===n?this.toString():this._value}}function c(n){if(null==n)return;const t=new l(n);return new Proxy(t,{get(n,t){if(t in n){const e=n[t];return"function"==typeof e?e.bind(n):e}if("string"==typeof t&&!Number.isNaN(Number(t))){const e=Number(t);if(Array.isArray(n._value)&&e>=0&&e<n._value.length)return n._value[e]}if(null!==n._value&&void 0!==n._value&&"object"==typeof n._value){const e=n._value;if(t in e){const n=e[t];return null!=n&&"object"==typeof n?c(n):n}}},set:(n,t,e)=>null!==n._value&&void 0!==n._value&&"object"==typeof n._value&&(n._value[t]=e,!0),has:(n,t)=>t in n||null!==n._value&&void 0!==n._value&&"object"==typeof n._value&&t in n._value})}function h(...n){if(0!==n.length)return c(n[0])}Object.entries(u).forEach(([n,t])=>{l.prototype[n]=function(...n){return t.apply(this,n)}}),Object.entries(u).forEach(([n,t])=>{h[n]=(...e)=>{if(e.length>0){const t=e[0],r=new l(t),i=r[n].call(r,...e.slice(1));return"chain"===n?i:i&&"object"==typeof i&&"__isLodash"in i&&!0===i.__isLodash?i._value:i}return t.call({_value:void 0,constructor:l})}});const f=h;class d{constructor(n){this.context=this.createSecurityContext(n)}getSecurityContext(){return this.context}createEvaluationContext(n){const t={...n},{level:e}=this.context;if(e.allowedGlobals.length>0){const n={};for(const r of e.allowedGlobals)r in t&&(n[r]=t[r]);return n}return t}validateExpression(n){const t=[];let e;if(this.context.options.unsafe)return{valid:!0,errors:[]};if(this.shouldUseVM()){const r=[{pattern:/eval\s*\(/,name:"eval"},{pattern:/Function\s*\(/,name:"Function"},{pattern:/setTimeout/,name:"setTimeout"},{pattern:/setInterval/,name:"setInterval"},{pattern:/global\./,name:"global"},{pattern:/globalThis\./,name:"globalThis"},{pattern:/process\./,name:"process"},{pattern:/__dirname/,name:"__dirname"},{pattern:/__filename/,name:"__filename"},{pattern:/this\.constructor/,name:"this.constructor"},{pattern:/constructor\.constructor/,name:"constructor.constructor"},{pattern:/arguments\.callee/,name:"arguments.callee"},{pattern:/Buffer\./,name:"Buffer"},{pattern:/while\s*\(\s*true\s*\)/,name:"while(true)"},{pattern:/for\s*\(\s*;;\s*\)/,name:"for(;;)"},{pattern:/performance\.now/,name:"performance.now"},{pattern:/process\.hrtime/,name:"process.hrtime"},{pattern:/\[\s*['"`]constructor['"`]\s*\]/,name:'["constructor"]'},{pattern:/window\./,name:"window"},{pattern:/document\./,name:"document"},{pattern:/\[\s*['"`]eval['"`]\s*\]/,name:'["eval"]'},{pattern:/\(\s*\d+\s*,\s*eval\s*\)/,name:"(1, eval)"},{pattern:/\[\s*['"`]Function['"`]\s*\]/,name:'["Function"]'},{pattern:/require\s*\(/,name:"require"},{pattern:/import\s*\(/,name:"import"},{pattern:/execSync/,name:"execSync"},{pattern:/exec/,name:"exec"},{pattern:/spawn/,name:"spawn"},{pattern:/fork/,name:"fork"},{pattern:/readFile/,name:"readFile"},{pattern:/writeFile/,name:"writeFile"},{pattern:/readFileSync/,name:"readFileSync"},{pattern:/writeFileSync/,name:"writeFileSync"},{pattern:/createReadStream/,name:"createReadStream"},{pattern:/createWriteStream/,name:"createWriteStream"}],i=[];for(const{pattern:t,name:e}of r)t.test(n)&&i.push(e);i.length>0&&(t.push(`Expression contains dangerous patterns: ${i.join(", ")}`),e=`Security error: Expression contains dangerous patterns: ${i.join(", ")}`)}return{valid:0===t.length,errors:t,...void 0!==e&&{formattedError:e}}}shouldUseVM(){return this.context.level.useVM}getTimeout(){return this.context.level.timeout}getMemoryLimit(){return this.context.level.memoryLimit}getVMConfig(){return this.context.vmConfig}getCapabilities(){return this.context.capabilities}getWarnings(){return this.context.warnings}createSecurityContext(n){let t,e,r;return n.unsafe?t=this.createUnsafeLevel(n):(t=this.createSandboxLevel(n),e=this.createSandboxVMConfig(n),r=this.createSandboxCapabilities()),{level:t,options:n,warnings:[],...void 0!==e&&{vmConfig:e},...void 0!==r&&{capabilities:r}}}createSandboxLevel(n){return{allowNetwork:!1,allowShell:!1,allowFileSystem:!1,allowDynamicImports:!1,allowedGlobals:[],timeout:Number(n.cpuLimit)||3e4,memoryLimit:Number(n.memoryLimit)||128,...n.cpuLimit&&{cpuLimit:Number(n.cpuLimit)},maxContextSize:10485760,useVM:!0}}createUnsafeLevel(n){return{allowNetwork:!0,allowShell:!0,allowFileSystem:!0,allowDynamicImports:!0,allowedGlobals:[],useVM:!1}}createSandboxVMConfig(n){return{memoryLimit:Number(n.memoryLimit)||128,timeout:Number(n.cpuLimit)||3e4,...n.cpuLimit&&{cpuLimit:Number(n.cpuLimit)},enableAsync:!0,enableGenerators:!0,enableProxies:!1,enableSymbols:!0,maxContextSize:10485760,recycleIsolates:!0,isolatePoolSize:3}}createSandboxCapabilities(){return{console:!0,timers:!1,promises:!0,json:!0,math:!0,date:!0,array:!0,object:!0,string:!0,number:!0,boolean:!0,regexp:!0,error:!0,map:!0,set:!0,weakmap:!0,weakset:!0,proxy:!1,reflect:!0,symbol:!0,bigint:!0,intl:!1,buffer:!1,url:!1,crypto:!1}}}var p=e(593);class y{constructor(n){return this.data=n,new Proxy(this,{get(n,t,e){if(t in n){const r=Reflect.get(n,t,e);if("function"==typeof r){let e=y.methodCache.get(n);e||(e=new Map,y.methodCache.set(n,e));const i=String(t);let a=e.get(i);return!a&&r&&(a=r.bind(n)),a&&e.set(i,a),a}return r}if("string"==typeof t){if(n.isObject(n.data)&&t in n.data)return new y(n.data[t]);if(Array.isArray(n.data))return new y(void 0)}return new y(void 0)}})}get value(){return this.data}get(n){return this.isObject(this.data)&&n in this.data?new y(this.data[n]):new y(void 0)}filter(n){return Array.isArray(this.data)?new y(this.data.filter(n)):new y([])}map(n){return Array.isArray(this.data)?new y(this.data.map(n)):new y([])}find(n){return Array.isArray(this.data)?new y(this.data.find(n)):new y(void 0)}where(n,t){if(Array.isArray(this.data)){const e=this.data.filter(e=>!(!this.isObject(e)||!(n in e))&&e[n]===t);return new y(e)}return new y([])}pluck(n){if(Array.isArray(this.data)){const t=this.data.map(t=>{if(this.isObject(t)&&n in t)return t[n]}).filter(n=>void 0!==n);return new y(t)}return new y([])}sortBy(n){if(Array.isArray(this.data)){const t=[...this.data].sort((t,e)=>{let r,i;if("function"==typeof n)r=n(t),i=n(e);else{if(!this.isObject(t)||!this.isObject(e))return 0;r=t[n],i=e[n]}return"string"==typeof r&&"string"==typeof i?r.localeCompare(i):"number"==typeof r&&"number"==typeof i?r-i:0});return new y(t)}return new y([])}take(n){return Array.isArray(this.data)?new y(this.data.slice(0,n)):new y([])}skip(n){return Array.isArray(this.data)?new y(this.data.slice(n)):new y([])}uniqBy(n){if(Array.isArray(this.data)){const t=new Set,e=this.data.filter(e=>{const r=n(e);return!t.has(r)&&(t.add(r),!0)});return new y(e)}return new y([])}flatten(){return Array.isArray(this.data)?new y(this.data.flat()):new y([])}flattenDeep(){if(Array.isArray(this.data)){const n=t=>t.reduce((t,e)=>Array.isArray(e)?t.concat(n(e)):t.concat(e),[]);return new y(n(this.data))}return new y([])}compact(){return Array.isArray(this.data)?new y(this.data.filter(Boolean)):new y([])}chunk(n){if(Array.isArray(this.data)){const t=[];for(let e=0;e<this.data.length;e+=n)t.push(this.data.slice(e,e+n));return new y(t)}return new y([])}takeWhile(n){if(Array.isArray(this.data)){const t=[];for(const e of this.data){if(!n(e))break;t.push(e)}return new y(t)}return new y([])}drop(n){return Array.isArray(this.data)?new y(this.data.slice(n)):new y([])}dropWhile(n){if(Array.isArray(this.data)){let t=0;for(;t<this.data.length&&n(this.data[t]);)t++;return new y(this.data.slice(t))}return new y([])}reverse(){return Array.isArray(this.data)?new y([...this.data].reverse()):new y(this.data)}shuffle(){if(Array.isArray(this.data)){const n=[...this.data];for(let t=n.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[n[t],n[e]]=[n[e],n[t]]}return new y(n)}return new y(this.data)}sample(){if(Array.isArray(this.data)&&this.data.length>0){const n=Math.floor(Math.random()*this.data.length);return new y(this.data[n])}return new y(void 0)}sampleSize(n){if(Array.isArray(this.data)){const t=[...this.data].sort(()=>.5-Math.random());return new y(t.slice(0,n))}return new y([])}orderBy(n,t=[]){if(Array.isArray(this.data)){const e=[...this.data].sort(this.createOrderByComparator(n,t));return new y(e)}return new y([])}createOrderByComparator(n,t){return(e,r)=>{for(let i=0;i<n.length;i++){const a=n[i];if(!a)continue;const s=t[i]||"asc";let o,u;if("function"==typeof a)o=a(e),u=a(r);else{if(!this.isObject(e)||!this.isObject(r))continue;o=e[a],u=r[a]}let l=0;if(null!==o&&null!==u&&void 0!==o&&void 0!==u&&(o<u?l=-1:o>u&&(l=1)),0!==l)return"desc"===s?-l:l}return 0}}groupBy(n){if(Array.isArray(this.data)){const t={};for(const e of this.data){const r=n(e);t[r]||(t[r]=[]),t[r].push(e)}return new y(t)}return new y({})}countBy(n){if(Array.isArray(this.data)){const t={};for(const e of this.data){const r=n(e);t[r]=(t[r]||0)+1}return new y(t)}return new y({})}keyBy(n){if(Array.isArray(this.data)){const t={};for(const e of this.data)t[n(e)]=e;return new y(t)}return new y({})}pick(n){if(this.isObject(this.data)){const t=this.data,e={};for(const r of n)r in t&&(e[r]=t[r]);return new y(e)}return new y({})}omit(n){if(this.isObject(this.data)){const t={...this.data};for(const e of n)delete t[e];return new y(t)}return new y({})}invert(){if(this.isObject(this.data)){const n=this.data,t={};for(const[e,r]of Object.entries(n))t[String(r)]=e;return new y(t)}return new y({})}mean(){if(Array.isArray(this.data)){const n=this.data.filter(n=>"number"==typeof n);if(0===n.length)return new y(0);const t=n.reduce((n,t)=>n+t,0);return new y(t/n.length)}return new y(0)}min(){if(Array.isArray(this.data)){const n=this.data.filter(n=>"number"==typeof n);return new y(n.length>0?Math.min(...n):void 0)}return new y(void 0)}max(){if(Array.isArray(this.data)){const n=this.data.filter(n=>"number"==typeof n);return new y(n.length>0?Math.max(...n):void 0)}return new y(void 0)}minBy(n){if(Array.isArray(this.data)&&this.data.length>0){const t=this.data.reduce((t,e)=>n(e)<n(t)?e:t);return new y(t)}return new y(void 0)}maxBy(n){if(Array.isArray(this.data)&&this.data.length>0){const t=this.data.reduce((t,e)=>n(e)>n(t)?e:t);return new y(t)}return new y(void 0)}size(){return Array.isArray(this.data)?new y(this.data.length):this.isObject(this.data)?new y(Object.keys(this.data).length):new y(0)}isEmpty(){return null==this.data?new y(!0):Array.isArray(this.data)||"string"==typeof this.data?new y(0===this.data.length):this.isObject(this.data)?new y(0===Object.keys(this.data).length):new y(!1)}includes(n){return Array.isArray(this.data)?new y(this.data.includes(n)):this.isObject(this.data)?new y(Object.values(this.data).includes(n)):new y(!1)}length(){return Array.isArray(this.data)?new y(this.data.length):this.isObject(this.data)?new y(Object.keys(this.data).length):new y(0)}sum(n){if(Array.isArray(this.data)){const t=(n?this.data.map(t=>this.isObject(t)?t[n]:0):this.data).reduce((n,t)=>n+("number"==typeof t?t:0),0);return new y(t)}return new y(0)}keys(){return this.isObject(this.data)?new y(Object.keys(this.data)):new y([])}values(){return this.isObject(this.data)?new y(Object.values(this.data)):new y([])}entries(){return this.isObject(this.data)?new y(Object.entries(this.data)):new y([])}flatMap(n){if(Array.isArray(this.data)){const t=[];for(let e=0;e<this.data.length;e++){const r=n(this.data[e],e);Array.isArray(r)?t.push(...r):t.push(r)}return new y(t)}return new y([])}mapValues(n){if(this.isObject(this.data)){const t=this.data,e={};for(const[r,i]of Object.entries(t))e[r]=n(i,r);return new y(e)}return new y({})}isObject(n){return"object"==typeof n&&null!==n&&!Array.isArray(n)}valueOf(){return this.data}toString(){return JSON.stringify(this.data,null,2)}toJSON(){return this.data}[Symbol.toPrimitive](n){return"default"===n||"string"===n?this.data:"number"===n?"number"==typeof this.data?this.data:Number(this.data):this.data}partition(n){if(Array.isArray(this.data)){const t=[],e=[];for(let r=0;r<this.data.length;r++)n(this.data[r],r)?t.push(this.data[r]):e.push(this.data[r]);return new y([t,e])}return new y([[],[]])}windowed(n,t=1){if(Array.isArray(this.data)){if(n<=0)return new y([]);const e=[];for(let r=0;r<=this.data.length-n;r+=t)e.push(this.data.slice(r,r+n));return new y(e)}return new y([])}chunked(n){return this.chunk(n)}span(n){if(Array.isArray(this.data)){let t=this.data.length;for(let e=0;e<this.data.length;e++)if(!n(this.data[e],e)){t=e;break}const e=this.data.slice(0,t),r=this.data.slice(t);return new y([e,r])}return new y([[],[]])}breakAt(n){return this.span((t,e)=>!n(t,e))}takeUntil(n){if(Array.isArray(this.data)){const t=[];for(let e=0;e<this.data.length&&!n(this.data[e],e);e++)t.push(this.data[e]);return new y(t)}return new y([])}dropUntil(n){if(Array.isArray(this.data)){let t=0;for(;t<this.data.length&&!n(this.data[t],t);)t++;return new y(this.data.slice(t))}return new y([])}frequencies(){if(Array.isArray(this.data)){const n={};for(const t of this.data){const e=String(t);n[e]=(n[e]||0)+1}return new y(n)}return new y({})}groupWith(n,t){if(Array.isArray(this.data)){const e={};for(const r of this.data){const i=n(r),a=t(r);e[i]||(e[i]=[]),e[i].push(a)}return new y(e)}return new y({})}reduceBy(n,t,e){if(Array.isArray(this.data)){const r={};for(const i of this.data){const a=n(i);r[a]=r[a]?t(r[a],i):t(e,i)}return new y(r)}return new y({})}scanLeft(n,t){if(Array.isArray(this.data)){const e=[t];let r=t;for(let t=0;t<this.data.length;t++)r=n(r,this.data[t],t),e.push(r);return new y(e)}return new y([t])}scan(n,t){return this.scanLeft(n,t)}scanRight(n,t){if(Array.isArray(this.data)){const e=[t];let r=t;for(let t=this.data.length-1;t>=0;t--)r=n(this.data[t],r,t),e.unshift(r);return new y(e)}return new y([t])}distinctBy(n){if(Array.isArray(this.data)){const t=[],e=[];for(const r of this.data){const i=n(r);t.includes(i)||(t.push(i),e.push(r))}return new y(e)}return new y([])}intersectBy(n,t){if(Array.isArray(this.data)){const e=n.map(t),r=this.data.filter(n=>e.includes(t(n)));return new y(r)}return new y([])}spy(n){if(Array.isArray(this.data))for(let t=0;t<this.data.length;t++)n(this.data[t],t);return new y(this.data)}filterMap(n){if(Array.isArray(this.data)){const t=[];for(let e=0;e<this.data.length;e++){const r=n(this.data[e],e);null!=r&&t.push(r)}return new y(t)}return new y([])}findLast(n){if(Array.isArray(this.data))for(let t=this.data.length-1;t>=0;t--)if(n(this.data[t],t))return new y(this.data[t]);return new y(void 0)}quantify(n){if(Array.isArray(this.data)){let t=0;for(let e=0;e<this.data.length;e++)n(this.data[e],e)&&t++;return new y(t)}return new y(0)}pairwise(){if(Array.isArray(this.data)&&this.data.length>=2){const n=[];for(let t=0;t<this.data.length-1;t++)n.push([this.data[t],this.data[t+1]]);return new y(n)}return new y([])}intersperse(n){if(Array.isArray(this.data)){if(this.data.length<=1)return new y(this.data);const t=[this.data[0]];for(let e=1;e<this.data.length;e++)t.push(n,this.data[e]);return new y(t)}return new y([])}peekable(){if(Array.isArray(this.data)){const n=this.data;let t=0;return new y({hasNext:()=>t<n.length,next:()=>t<n.length?n[t++]:void 0,peek:()=>t<n.length?n[t]:void 0,remaining:()=>n.slice(t)})}return new y({hasNext:()=>!1,next:()=>{},peek:()=>{},remaining:()=>[]})}batched(n,t){if(Array.isArray(this.data)){if(n<=0)return new y([]);const e=[];for(let r=0;r<this.data.length;r+=n){const i=this.data.slice(r,r+n);if(void 0!==t&&i.length<n&&r+n>this.data.length)for(;i.length<n;)i.push(t);e.push(i)}return new y(e)}return new y([])}reduce(n,t){return Array.isArray(this.data)?this.data.reduce((t,e,r)=>n(t,e,r),t):t}fold(n,t){return this.reduce(n,t)}foldLeft(n,t){if(Array.isArray(this.data)){let e=n;for(let n=0;n<this.data.length;n++)e=t(e,this.data[n],n);return new y(e)}return new y(n)}foldRight(n,t){if(Array.isArray(this.data)){let e=n;for(let n=this.data.length-1;n>=0;n--)e=t(this.data[n],e,n);return new y(e)}return new y(n)}traverse(n,t){if(Array.isArray(this.data)){const e=[];let r=n;for(let n=0;n<this.data.length;n++){const{value:i,state:a}=t(r,this.data[n],n);e.push(i),r=a}return new y({values:e,finalState:r})}return new y({values:[],finalState:n})}delay(n){return new Promise(t=>{setTimeout(()=>t(new y(this.data)),n)})}debounceTime(n){return new Promise(t=>{if(!Array.isArray(this.data))return void setTimeout(()=>t(new y(this.data)),n);const e=this.data;0!==e.length?setTimeout(()=>{t(new y(e[e.length-1]))},n):t(new y([]))})}throttleTime(n){return new Promise(t=>{if(!Array.isArray(this.data))return void t(new y(this.data));const e=this.data;0!==e.length?setTimeout(()=>{t(new y(e[0]))},n):t(new y([]))})}timeout(n){return Promise.race([new Promise(n=>{n(new y(this.data))}),new Promise((t,e)=>{setTimeout(()=>e(new Error(`Operation timed out after ${n}ms`)),n)})])}async*interval(n){if(!Array.isArray(this.data))return void(yield new y(this.data));const t=this.data;for(const e of t)yield new y(e),await new Promise(t=>setTimeout(t,n))}async*timer(n,t){if(await new Promise(t=>setTimeout(t,n)),!Array.isArray(this.data))return void(yield new y(this.data));const e=this.data;let r=0;for(;r<e.length;)yield new y(e[r++]),t&&r<e.length&&await new Promise(n=>setTimeout(n,t))}async concatMap(n){if(!Array.isArray(this.data)){const t=await Promise.resolve(n(this.data,0));return new y(t)}const t=this.data,e=[];for(let r=0;r<t.length;r++){const i=await Promise.resolve(n(t[r],r));Array.isArray(i)?e.push(...i):e.push(i)}return new y(e)}async mergeMap(n){if(!Array.isArray(this.data)){const t=await Promise.resolve(n(this.data,0));return new y(t)}const t=this.data.map((t,e)=>Promise.resolve(n(t,e))),e=await Promise.all(t),r=[];for(const n of e)Array.isArray(n)?r.push(...n):r.push(n);return new y(r)}async switchMap(n){if(!Array.isArray(this.data)){const t=await Promise.resolve(n(this.data,0));return new y(t)}const t=this.data;if(0===t.length)return new y([]);const e=t[t.length-1],r=await Promise.resolve(n(e,t.length-1));return new y(Array.isArray(r)?r:[r])}async exhaustMap(n){if(!Array.isArray(this.data)){const t=await Promise.resolve(n(this.data,0));return new y(t)}const t=this.data;if(0===t.length)return new y([]);const e=t[0],r=await Promise.resolve(n(e,0));return new y(Array.isArray(r)?r:[r])}distinctUntilChanged(n){if(!Array.isArray(this.data))return new y(this.data);const t=this.data;if(0===t.length)return new y([]);const e=[t[0]];let r=n?n(t[0]):t[0];for(let i=1;i<t.length;i++){const a=n?n(t[i]):t[i];a!==r&&(e.push(t[i]),r=a)}return new y(e)}skipLast(n){if(!Array.isArray(this.data))return new y(n>0?void 0:this.data);const t=this.data;if(n<=0)return new y(t);const e=t.slice(0,Math.max(0,t.length-n));return new y(e)}takeLast(n){if(!Array.isArray(this.data))return new y(n>0?this.data:void 0);const t=this.data;if(n<=0)return new y([]);const e=t.slice(Math.max(0,t.length-n));return new y(e)}combineLatest(n){if(!Array.isArray(this.data))return new y([this.data,...n.map(n=>n[n.length-1]||null)]);const t=this.data,e=Math.max(t.length,...n.map(n=>n.length)),r=[];for(let i=0;i<e;i++){const e=[i<t.length?t[i]:t[t.length-1]||null];for(const t of n)e.push(i<t.length?t[i]:t[t.length-1]||null);r.push(e)}return new y(r)}zip(n){const t=Array.isArray(n)&&n.length>0&&!Array.isArray(n[0])?[n]:n;if(!Array.isArray(this.data))return new y([this.data,...t.map(n=>n[0]||null)]);const e=this.data,r=Math.min(e.length,...t.map(n=>n.length)),i=[];for(let n=0;n<r;n++){const r=[e[n]];for(const e of t)r.push(e[n]);i.push(r)}return new y(i)}zipWith(n,t){if(!Array.isArray(this.data))return new y([]);const e=this.data,r=Array.isArray(n)?n:[],i=Math.min(e.length,r.length),a=[];for(let n=0;n<i;n++)a.push(t(e[n],r[n],n));return new y(a)}unzip(){if(!Array.isArray(this.data))return new y([[],[]]);const n=[],t=[];for(const e of this.data)Array.isArray(e)&&e.length>=2&&(n.push(e[0]),t.push(e[1]));return new y([n,t])}merge(n){if(!Array.isArray(this.data)){const t=[this.data];for(const e of n)t.push(...e);return new y(t)}const t=[...this.data];for(const e of n)t.push(...e);return new y(t)}async retry(n,t){let e=0;const r=n+1;for(;e<r;)try{if(t){const n=await t();return new y(n)}return new y(this.data)}catch(n){if(e++,e>=r)throw n;await new Promise(n=>setTimeout(n,1e3*2**(e-1)))}return new y(this.data)}async catchError(n){try{return new y(this.data)}catch(t){const e=await Promise.resolve(n(t));return new y(e)}}forEach(n){if(Array.isArray(this.data)){const t=this.data;t.forEach((e,r)=>{n(e,r,t)})}else n(this.data,0,[this.data]);return new y(this.data)}each(n){return this.forEach(n)}async forEachAsync(n){return Array.isArray(this.data)?await(async(n,t)=>{await Promise.all(n.map((e,r)=>t(e,r,n)))})(this.data,n):await n(this.data,0,[this.data]),new y(this.data)}async forEachAsyncSeq(n){return Array.isArray(this.data)?await(async(n,t)=>{for(let e=0;e<n.length;e++)await t(n[e],e,n)})(this.data,n):await n(this.data,0,[this.data]),new y(this.data)}async mapAsync(n){if(Array.isArray(this.data)){const t=await(async(n,t)=>Promise.all(n.map((e,r)=>t(e,r,n))))(this.data,n);return new y(t)}const t=await n(this.data,0);return new y([t])}async mapAsyncSeq(n){if(Array.isArray(this.data)){const t=await(async(n,t)=>{const e=[];for(let r=0;r<n.length;r++)e.push(await t(n[r],r,n));return e})(this.data,n);return new y(t)}const t=await n(this.data,0);return new y([t])}tap(n){return Array.isArray(this.data)?this.data.forEach((t,e)=>{n(t,e)}):n(this.data,0),new y(this.data)}startWith(n){return Array.isArray(this.data)?new y([n,...this.data]):new y([n,this.data])}iterate(n,t){const e=[];let r=this.data;for(let i=0;i<t;i++)e.push(r),r=n(r,i);return new y(e)}unfold(n,t){const e=[];let r=void 0!==t?t:this.data,i=n(r);for(;null!=i&&Array.isArray(i)&&2===i.length;)e.push(i[0]),r=i[1],i=n(r);return new y(e)}cycle(n=1){if(!Array.isArray(this.data)||0===this.data.length)return new y([]);const t=[];for(let e=0;e<n;e++)t.push(...this.data);return new y(t)}intercalate(n){if(!Array.isArray(this.data))return new y([]);const t=[];for(let e=0;e<this.data.length;e++)e>0&&void 0!==n&&(Array.isArray(n)?t.push(...n):t.push(n)),Array.isArray(this.data[e])?t.push(...this.data[e]):t.push(this.data[e]);return new y(t)}transpose(){if(!Array.isArray(this.data)||0===this.data.length)return new y([]);const n=this.data,t=Math.max(...n.map(n=>Array.isArray(n)?n.length:0)),e=[];for(let r=0;r<t;r++){const t=[];for(let e=0;e<n.length;e++)Array.isArray(n[e])&&r<n[e].length&&t.push(n[e][r]);e.push(t)}return new y(e)}tee(...n){const t=n.map(n=>n(this.data));return new y(t)}debug(n){const t=n?`[${n}] `:"";return console.log(`${t}Debug:`,this.data),this}benchmark(n,t){const e=performance.now(),r=n(this.data),i=performance.now()-e,a=t?`[${t}] `:"";return console.log(`${a}Benchmark: ${i}ms`),new y(r)}memoize(n,t){const e=new Map,r=t?t(this.data):JSON.stringify(this.data);if(e.has(r))return new y(e.get(r));const i=n(this.data);return e.set(r,i),new y(i)}partitionBy(...n){if(!Array.isArray(this.data))return new y(Array(n.length+1).fill([]));const t=Array(n.length+1).fill(null).map(()=>[]);for(let e=0;e<this.data.length;e++){let r=!1;for(let i=0;i<n.length;i++)if(n[i](this.data[e],e)){t[i].push(this.data[e]),r=!0;break}r||t[n.length].push(this.data[e])}return new y(t)}head(){if(Array.isArray(this.data))return this.data[0]}tail(){return Array.isArray(this.data)?new y(this.data.slice(1)):new y([])}init(){return Array.isArray(this.data)?new y(this.data.slice(0,-1)):new y([])}last(){if(Array.isArray(this.data))return this.data[this.data.length-1]}cons(n){return Array.isArray(this.data)?new y([n,...this.data]):new y([n])}snoc(n){return Array.isArray(this.data)?new y([...this.data,n]):new y([n])}sliding(n,t=1){return this.windowed(n,t)}enumerate(){if(!Array.isArray(this.data))return new y([]);const n=[];for(let t=0;t<this.data.length;t++)n.push([t,this.data[t]]);return new y(n)}groupByMultiple(...n){if(!Array.isArray(this.data))return new y({});const t={};for(let e=0;e<this.data.length;e++){const r=n.map(n=>n(this.data[e],e)),i=JSON.stringify(r);t[i]||(t[i]={keys:r,items:[]}),t[i].items.push(this.data[e])}return new y(Object.values(t))}[Symbol.iterator](){return Array.isArray(this.data)?this.data[Symbol.iterator]():[][Symbol.iterator]()}}y.methodCache=new WeakMap;const m=["map","filter","find","reduce","groupBy","sortBy","orderBy","slice","flatten","flattenDeep","flatMap","uniq","uniqBy","compact","chunk","pluck","where","findWhere","first","last","take","takeWhile","drop","dropWhile","skip","sample","sampleSize","shuffle","reverse","keys","values","entries","pick","omit","invert","defaults","merge","assignIn","assignWith","extend","mapValues","clone","has","includes","get","set","sum","mean","min","minBy","max","maxBy","count","countBy","keyBy","size","isEmpty","isArray","isObject","isString","isNumber","toArray","partition","windowed","chunked","span","takeUntil","dropUntil","frequencies","groupWith","reduceBy","scanLeft","distinctBy","intersectBy","spy","filterMap","findLast","quantify","pairwise","intersperse","peekable","batched","fold","foldLeft","foldRight","traverse","scan","scanRight","delay","debounceTime","throttleTime","timeout","interval","timer","concatMap","mergeMap","switchMap","exhaustMap","distinctUntilChanged","skipLast","takeLast","combineLatest","zip","zipWith","unzip","merge","retry","catchError","tap","startWith","forEach","each","forEachAsync","forEachAsyncSeq","mapAsync","mapAsyncSeq","head","tail","init","last","cons","snoc","breakAt","iterate","unfold","cycle","intercalate","transpose","tee","debug","benchmark","memoize","partitionBy","sliding","enumerate","groupByMultiple"];function g(n){if(null==n){const t=(...t)=>0===t.length?n:new y(t[0]);return Object.defineProperty(t,"valueOf",{value:()=>n}),Object.defineProperty(t,"toString",{value:()=>String(n)}),Object.defineProperty(t,"toJSON",{value:()=>n}),Object.defineProperty(t,Symbol.toPrimitive,{value:t=>"default"===t||"string"===t?n:"number"===t?"number"==typeof n?n:Number(n):n}),t}if(Array.isArray(n)){const t=[...n];return Object.defineProperty(t,"data",{value:n,enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(t,"value",{value:n,enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(t,"constructor",{value:Array,enumerable:!1,configurable:!0,writable:!0}),w(t,n),Object.defineProperty(t,"chain",{value:()=>new y(n),enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(t,"toJSON",{value:()=>n,enumerable:!1,configurable:!0}),Object.defineProperty(t,"valueOf",{value:()=>n,enumerable:!1,configurable:!0}),Object.defineProperty(t,"toString",{value:()=>JSON.stringify(n),enumerable:!1,configurable:!0}),t}const t=(...t)=>0===t.length?new y(n):new y(t[0]);if("object"==typeof n&&!Array.isArray(n)){const e=n;for(const[n,r]of Object.entries(e))m.includes(n)||Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!1});return new Proxy(t,{get(n,t,r){if("hasOwnProperty"===t)return n=>Object.hasOwn(e,n);if("propertyIsEnumerable"===t)return n=>Object.prototype.propertyIsEnumerable.call(e,n);if("toJSON"===t)return()=>e;if("valueOf"===t)return()=>e;if("toString"===t)return()=>JSON.stringify(e);if("string"==typeof t&&Object.hasOwn(e,t)){const n=e[t];return m.includes(t),new y(n)}const i=Reflect.get(n,t,r);return void 0!==i?i:void 0},getOwnPropertyDescriptor:(n,t)=>"string"==typeof t&&t in e?{configurable:!0,enumerable:!0,value:e[t],writable:!1}:Reflect.getOwnPropertyDescriptor(n,t),has:(n,t)=>t in e||Reflect.has(n,t),ownKeys:()=>Object.keys(e)})}return Object.defineProperty(t,"hasOwnProperty",{value:Object.prototype.hasOwnProperty,enumerable:!1,configurable:!0}),Object.defineProperty(t,"propertyIsEnumerable",{value:Object.prototype.propertyIsEnumerable,enumerable:!1,configurable:!0}),w(t,n),Object.defineProperty(t,"toJSON",{value:()=>n,enumerable:!1,configurable:!0}),Object.defineProperty(t,"valueOf",{value:()=>n,enumerable:!1,configurable:!0}),Object.defineProperty(t,"toString",{value:()=>"string"==typeof n?n:"number"==typeof n||"boolean"==typeof n?String(n):JSON.stringify(n),enumerable:!1,configurable:!0}),Object.defineProperty(t,Symbol.for("nodejs.util.inspect.custom"),{value:()=>n,enumerable:!1,configurable:!0}),Object.defineProperty(t,"__isSmartDollar",{value:!0,enumerable:!1,configurable:!1,writable:!1}),Object.defineProperty(t,"_value",{value:n,enumerable:!1,configurable:!1,writable:!1}),t}function w(n,t){const e=new y(t);for(const r of m)if(r in e&&"function"==typeof e[r]){if("object"==typeof t&&!Array.isArray(t)&&null!==t&&r in t)continue;Object.defineProperty(n,r,{value:(...n)=>{const i=e[r];if("function"!=typeof i)throw new Error(`${r} is not a function`);const a=i(...n);if(Array.isArray(t))return a;if(a&&"object"==typeof a&&"value"in a){const n=a.value;return Array.isArray(n)?g(n):n}return a},enumerable:!1,configurable:!0,writable:!1})}Object.defineProperty(n,"chain",{value:()=>new y(t),enumerable:!1,configurable:!0,writable:!1})}let v,b,A,_=!1;async function j(){if(!_){try{const n=await Promise.all([e.e(80),e.e(367)]).then(e.bind(e,367));v=n.VMSandboxSimple}catch(n){console.error("Failed to load vm-sandbox-simple module:",n)}try{const n=await Promise.all([e.e(80),e.e(525)]).then(e.bind(e,525));b=n.VMSandboxQuickJS}catch(n){console.error("Failed to load vm-sandbox-quickjs module:",n)}try{const n=await e.e(80).then(e.bind(e,80));A=n.getVMEngineType}catch(n){console.error("Failed to load VMEngineFactory module:",n)}_=!0}}class k{constructor(n,t){this.vmSandbox=null,this.options=n,this.appContext=t,this.securityManager=new d(n)}async dispose(){this.vmSandbox&&(await this.vmSandbox.dispose(),this.vmSandbox=null)}showSecurityWarnings(){const n=this.securityManager.getWarnings();for(const t of n)console.error(t)}async evaluate(n,t,e){await j();try{this.showSecurityWarnings();const r=this.transformExpression(n),i=this.securityManager.validateExpression(r);if(!i.valid){if(i.formattedError)throw new Error(i.formattedError);throw new Error(`Security validation failed: ${i.errors.join(", ")}`)}if("$"===r.trim()&&null==t)return t;if("_"===r.trim()&&!this.securityManager.shouldUseVM())return(await this.loadUtilities())(t);const a=this.securityManager.shouldUseVM()?t:g(t),s=await this.createEvaluationContext(a,t,e),o=this.securityManager.createEvaluationContext(s),u=await this.executeExpression(r,o);return this.unwrapResult(u)}catch(n){if(n instanceof Error&&n.message.includes("Security validation failed"))throw n;throw new Error(`Expression evaluation failed: ${n instanceof Error?n.message:"Unknown error"}`)}}transformExpression(n){const t=(0,p.transformExpression)(n,this.appContext?.expressionCache);return this.options.verbose&&t!==n&&console.error("Transformed expression:",t),t}async createEvaluationContext(n,t,e){return this.securityManager.shouldUseVM()?{console:this.createConsoleObject(),data:t,$:n,_:null,$_:e}:{$:n,console:this.createConsoleObject(),JSON,Math,Date,Array,Object,String,Number,Boolean,Set,Map,Reflect,Symbol,_:await this.loadUtilities(),$_:e,data:t}}createConsoleObject(){return{log:console.log,error:console.error,warn:console.warn,info:console.info,debug:this.options.verbose?console.debug:()=>{},trace:this.options.verbose?console.trace:()=>{},table:console.table,time:console.time,timeEnd:console.timeEnd,group:console.group,groupEnd:console.groupEnd,clear:console.clear,count:console.count,assert:console.assert,dir:console.dir}}async executeExpression(n,t){return this.securityManager.shouldUseVM()?(this.options.verbose&&console.error("🔒 Running in secure VM isolation mode"),await this.executeInVMSandbox(n,t)):(this.options.verbose&&console.error("⚡ Running in non-VM mode (should not happen)"),await this.safeEval(n,t))}async unwrapResult(n){if(this.debugResult(n),n instanceof Promise){const t=await n;return this.unwrapResult(t)}return this.isAsyncGenerator(n)?this.handleAsyncGenerator(n):this.isChainableWrapper(n)?this.unwrapChainableWrapper(n):this.isSmartDollar(n)?this.unwrapSmartDollar(n):n}debugResult(n){this.options.verbose&&(console.error("Debug: Result type:",typeof n,"isArray:",Array.isArray(n)),n&&"object"==typeof n&&(console.error("Debug: Result has value:","value"in n),console.error("Debug: Result constructor:",n.constructor?.name)))}isChainableWrapper(n){return null!==n&&"object"==typeof n&&!Array.isArray(n)&&"value"in n&&(n.constructor.name.includes("ChainableWrapper")||n.constructor.name.includes("_ChainableWrapper"))}isAsyncGenerator(n){return null!==n&&"object"==typeof n&&"next"in n&&"function"==typeof n.next&&Symbol.asyncIterator in n&&"function"==typeof n[Symbol.asyncIterator]}async handleAsyncGenerator(n){const t=[];for await(const e of n){const n=this.isChainableWrapper(e)?this.unwrapChainableWrapper(e):e;t.push(n)}return t}unwrapChainableWrapper(n){this.options.verbose&&console.error("Debug: Unwrapping result with .value");const t=n.value;return this.options.verbose&&console.error("Debug: Unwrapped value type:",typeof t),t}isSmartDollar(n){return null!==n&&"object"==typeof n&&"__isSmartDollar"in n&&!0===n.__isSmartDollar}unwrapSmartDollar(n){this.options.verbose&&console.error("Debug: Unwrapping SmartDollar object");const t=n,e=void 0!==t._value?t._value:t.value;return this.options.verbose&&console.error("Debug: Unwrapped SmartDollar value type:",typeof e),e}async safeEval(n,t){const e=Object.keys(t),r=Object.values(t);try{const t=new(0,Object.getPrototypeOf(async()=>{}).constructor)(...e,`\n        "use strict";\n        return (${n});\n      `);return await t(...r)}catch(t){if(t instanceof Error){const e=a.parseExpressionError(t,n),r=a.formatError(e,n);throw new Error(r)}throw new Error("Invalid expression: Syntax error")}}async loadUtilities(){return f}async executeInVMSandbox(n,t){if(await j(),!this.vmSandbox){const n=this.securityManager.getVMConfig();if(!n)throw new Error("VM configuration not available");if("quickjs"===(A?A():"quickjs")&&b)this.vmSandbox=new b(this.appContext,n),this.options.verbose&&console.error("Using QuickJS VM engine (on-demand)");else{if(!v)throw new Error("No VM sandbox available");this.vmSandbox=new v(this.appContext,n),this.options.verbose&&console.error("Using VM engine (on-demand)")}}try{const e=this.securityManager.getTimeout(),r=this.securityManager.getMemoryLimit(),i={...void 0!==e&&{timeout:e},...void 0!==r&&{memoryLimit:r},allowedGlobals:this.securityManager.getSecurityContext().level.allowedGlobals,allowNetwork:this.securityManager.getSecurityContext().level.allowNetwork};if(this.options.verbose){console.error("VM Context keys:",Object.keys(t));for(const[n,e]of Object.entries(t))console.error(`  ${n}: ${typeof e}${"function"==typeof e?` (${e.name||"anonymous"})`:""}`)}const a={};for(const[n,e]of Object.entries(t))a[n]=e;return(await this.vmSandbox.execute(n,a,i)).value}catch(t){if(t instanceof Error){if(this.options.verbose&&(console.error("VM execution error:",t.message),console.error("Expression:",n),console.error("Stack:",t.stack)),t.message.includes("Cannot find module"))throw new Error("VM module not found. Please ensure all dependencies are properly installed.");if(t.message.includes("QuickJS initialization failed"))throw t;let e=t.message;const r=e.match(/"message":"([^"]+)"/);throw r&&(e=r[1]),new Error(e)}throw t}}}}}]);