"use strict";(this.webpackChunkJSQ=this.webpackChunkJSQ||[]).push([[226],{201:(t,e,n)=>{n.d(e,{v:()=>r});const r="\n// Always define lodashMethods\nglobalThis.lodashMethods = {\n  // Array methods from lodash\n  filter: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const filtered = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        filtered.push(arr[i]);\n      }\n    }\n    return new this.constructor(filtered);\n  },\n  \n  map: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const mapped = [];\n    for (let i = 0; i < arr.length; i++) {\n      mapped.push(iteratee(arr[i], i, this._value));\n    }\n    return new this.constructor(mapped);\n  },\n  \n  find: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        return arr[i];\n      }\n    }\n    return undefined;\n  },\n  \n  findIndex: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return -1;\n    }\n    const arr = Array.from(this._value);\n    for (let i = 0; i < arr.length; i++) {\n      if (predicate(arr[i], i, this._value)) {\n        return i;\n      }\n    }\n    return -1;\n  },\n  \n  reduce: function(iteratee, accumulator) {\n    if (this._value === null || this._value === undefined) {\n      return accumulator;\n    }\n    const arr = Array.from(this._value);\n    let result = accumulator;\n    const startIndex = accumulator !== undefined ? 0 : 1;\n    if (accumulator === undefined && arr.length > 0) {\n      result = arr[0];\n    }\n    for (let i = startIndex; i < arr.length; i++) {\n      result = iteratee(result, arr[i], i, this._value);\n    }\n    return result;\n  },\n  \n  // Lodash specific array methods\n  where: function(properties) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const filtered = [];\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (!item || typeof item !== 'object') continue;\n      let matches = true;\n      for (const [key, val] of Object.entries(properties)) {\n        if (item[key] !== val) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        filtered.push(item);\n      }\n    }\n    return new this.constructor(filtered);\n  },\n  \n  pluck: function(property) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const plucked = [];\n    for (let i = 0; i < arr.length; i++) {\n      plucked.push(arr[i] ? arr[i][property] : undefined);\n    }\n    return new this.constructor(plucked);\n  },\n  \n  sortBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n      sorted.push(arr[i]);\n    }\n    // Simple bubble sort for VM compatibility\n    for (let i = 0; i < sorted.length - 1; i++) {\n      for (let j = 0; j < sorted.length - i - 1; j++) {\n        const aVal = typeof iteratee === 'function' ? iteratee(sorted[j]) : sorted[j][iteratee];\n        const bVal = typeof iteratee === 'function' ? iteratee(sorted[j + 1]) : sorted[j + 1][iteratee];\n        if (aVal > bVal) {\n          const temp = sorted[j];\n          sorted[j] = sorted[j + 1];\n          sorted[j + 1] = temp;\n        }\n      }\n    }\n    return new this.constructor(sorted);\n  },\n  \n  orderBy: function(iteratees, orders) {\n    const iterateeArr = Array.isArray(iteratees) ? iteratees : [iteratees];\n    const orderArr = Array.isArray(orders) ? orders : [orders];\n    \n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n      sorted.push(arr[i]);\n    }\n    \n    // Bubble sort with multiple keys\n    for (let i = 0; i < sorted.length - 1; i++) {\n      for (let j = 0; j < sorted.length - i - 1; j++) {\n        let shouldSwap = false;\n        \n        for (let k = 0; k < iterateeArr.length; k++) {\n          const iteratee = iterateeArr[k];\n          const order = orderArr[k] || 'asc';\n          const aVal = typeof iteratee === 'function' ? iteratee(sorted[j]) : sorted[j][iteratee];\n          const bVal = typeof iteratee === 'function' ? iteratee(sorted[j + 1]) : sorted[j + 1][iteratee];\n          \n          if (aVal < bVal) {\n            shouldSwap = order === 'desc';\n            break;\n          }\n          if (aVal > bVal) {\n            shouldSwap = order === 'asc';\n            break;\n          }\n        }\n        \n        if (shouldSwap) {\n          const temp = sorted[j];\n          sorted[j] = sorted[j + 1];\n          sorted[j + 1] = temp;\n        }\n      }\n    }\n    return new this.constructor(sorted);\n  },\n  \n  groupBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const grouped = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (!grouped[key]) grouped[key] = [];\n      grouped[key].push(item);\n    }\n    return new this.constructor(grouped);\n  },\n  \n  countBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const counted = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      counted[key] = (counted[key] || 0) + 1;\n    }\n    return new this.constructor(counted);\n  },\n  \n  keyBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const arr = Array.from(this._value);\n    const keyed = {};\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      keyed[key] = item;\n    }\n    return new this.constructor(keyed);\n  },\n  \n  take: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const taken = [];\n    for (let i = 0; i < Math.min(n, arr.length); i++) {\n      taken.push(arr[i]);\n    }\n    return new this.constructor(taken);\n  },\n  \n  skip: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const skipped = [];\n    for (let i = n; i < arr.length; i++) {\n      skipped.push(arr[i]);\n    }\n    return new this.constructor(skipped);\n  },\n  \n  drop: function(n) {\n    return this.skip(n);\n  },\n  \n  takeWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const taken = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) break;\n      taken.push(arr[i]);\n    }\n    return new this.constructor(taken);\n  },\n  \n  dropWhile: function(predicate) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    let dropIndex = 0;\n    for (let i = 0; i < arr.length; i++) {\n      if (!predicate(arr[i], i, arr)) {\n        dropIndex = i;\n        break;\n      }\n    }\n    const result = [];\n    for (let i = dropIndex; i < arr.length; i++) {\n      result.push(arr[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  uniq: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const unique = [];\n    const seen = {};\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      const key = typeof val === 'object' ? JSON.stringify(val) : String(val);\n      if (!seen[key]) {\n        seen[key] = true;\n        unique.push(val);\n      }\n    }\n    return new this.constructor(unique);\n  },\n  \n  uniqBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const seen = {};\n    const unique = [];\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);\n      if (!seen[keyStr]) {\n        seen[keyStr] = true;\n        unique.push(item);\n      }\n    }\n    return new this.constructor(unique);\n  },\n  \n  sample: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    return arr[Math.floor(Math.random() * arr.length)];\n  },\n  \n  sampleSize: function(n) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const shuffled = [];\n    for (let i = 0; i < arr.length; i++) {\n      shuffled.push(arr[i]);\n    }\n    // Fisher-Yates shuffle\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n    }\n    const result = [];\n    for (let i = 0; i < Math.min(n, shuffled.length); i++) {\n      result.push(shuffled[i]);\n    }\n    return new this.constructor(result);\n  },\n  \n  shuffle: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const shuffled = [];\n    for (let i = 0; i < arr.length; i++) {\n      shuffled.push(arr[i]);\n    }\n    // Fisher-Yates shuffle\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n    }\n    return new this.constructor(shuffled);\n  },\n  \n  flatten: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const flattened = [];\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      if (Array.isArray(val)) {\n        for (let j = 0; j < val.length; j++) {\n          flattened.push(val[j]);\n        }\n      } else {\n        flattened.push(val);\n      }\n    }\n    return new this.constructor(flattened);\n  },\n  \n  flattenDeep: function() {\n    const flattenDeepRecursive = (arr) => {\n      const result = [];\n      for (let i = 0; i < arr.length; i++) {\n        const val = arr[i];\n        if (Array.isArray(val)) {\n          const nested = flattenDeepRecursive(val);\n          for (let j = 0; j < nested.length; j++) {\n            result.push(nested[j]);\n          }\n        } else {\n          result.push(val);\n        }\n      }\n      return result;\n    };\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const flattened = flattenDeepRecursive(Array.from(this._value));\n    return new this.constructor(flattened);\n  },\n  \n  compact: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const compacted = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        compacted.push(arr[i]);\n      }\n    }\n    return new this.constructor(compacted);\n  },\n  \n  chunk: function(size) {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const chunks = [];\n    for (let i = 0; i < arr.length; i += size) {\n      const chunk = [];\n      for (let j = i; j < Math.min(i + size, arr.length); j++) {\n        chunk.push(arr[j]);\n      }\n      chunks.push(chunk);\n    }\n    return new this.constructor(chunks);\n  },\n  \n  reverse: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor([]);\n    }\n    const arr = Array.from(this._value);\n    const reversed = [];\n    for (let i = arr.length - 1; i >= 0; i--) {\n      reversed.push(arr[i]);\n    }\n    return new this.constructor(reversed);\n  },\n  \n  // Math methods\n  sum: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return 0;\n    }\n    const arr = Array.from(this._value);\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      let num;\n      if (iteratee && typeof iteratee === 'string') {\n        num = Number(val?.[iteratee]) || 0;\n      } else if (iteratee && typeof iteratee === 'function') {\n        num = Number(iteratee(val)) || 0;\n      } else {\n        num = Number(val) || 0;\n      }\n      sum += num;\n    }\n    return sum;\n  },\n  \n  mean: function() {\n    if (this._value === null || this._value === undefined) {\n      return NaN;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return NaN;\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += Number(arr[i]) || 0;\n    }\n    return sum / arr.length;\n  },\n  \n  min: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let min = Number(arr[0]) || 0;\n    for (let i = 1; i < arr.length; i++) {\n      const num = Number(arr[i]) || 0;\n      if (num < min) min = num;\n    }\n    return min;\n  },\n  \n  max: function() {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let max = Number(arr[0]) || 0;\n    for (let i = 1; i < arr.length; i++) {\n      const num = Number(arr[i]) || 0;\n      if (num > max) max = num;\n    }\n    return max;\n  },\n  \n  minBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let min = arr[0];\n    let minVal = typeof iteratee === 'function' ? iteratee(min) : min[iteratee];\n    for (let i = 1; i < arr.length; i++) {\n      const item = arr[i];\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (itemVal < minVal) {\n        min = item;\n        minVal = itemVal;\n      }\n    }\n    return min;\n  },\n  \n  maxBy: function(iteratee) {\n    if (this._value === null || this._value === undefined) {\n      return undefined;\n    }\n    const arr = Array.from(this._value);\n    if (arr.length === 0) return undefined;\n    let max = arr[0];\n    let maxVal = typeof iteratee === 'function' ? iteratee(max) : max[iteratee];\n    for (let i = 1; i < arr.length; i++) {\n      const item = arr[i];\n      const itemVal = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];\n      if (itemVal > maxVal) {\n        max = item;\n        maxVal = itemVal;\n      }\n    }\n    return max;\n  },\n  \n  // Object methods\n  pick: function(...args) {\n    const result = {};\n    const obj = this._value;\n    // Support both array syntax and spread syntax\n    const keys = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;\n    if (obj && typeof obj === 'object') {\n      for (const key of keys) {\n        if (key in obj) {\n          result[key] = obj[key];\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  omit: function(...args) {\n    const result = {};\n    const obj = this._value;\n    // Support both array syntax and spread syntax\n    const keys = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;\n    if (obj && typeof obj === 'object') {\n      for (const key in obj) {\n        if (!keys.includes(key)) {\n          result[key] = obj[key];\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  keys: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.keys(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  values: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.values(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  entries: function() {\n    if (this._value && typeof this._value === 'object') {\n      return new this.constructor(Object.entries(this._value));\n    }\n    return new this.constructor([]);\n  },\n  \n  fromPairs: function() {\n    if (this._value === null || this._value === undefined) {\n      return new this.constructor({});\n    }\n    const pairs = Array.from(this._value);\n    const result = {};\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (Array.isArray(pair) && pair.length >= 2) {\n        result[pair[0]] = pair[1];\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  invert: function() {\n    const result = {};\n    const obj = this._value;\n    if (obj && typeof obj === 'object') {\n      for (const [key, value] of Object.entries(obj)) {\n        result[String(value)] = key;\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  merge: function(...sources) {\n    const merged = Object.assign({}, this._value, ...sources);\n    return new this.constructor(merged);\n  },\n  \n  defaults: function(...sources) {\n    const result = { ...this._value };\n    for (const source of sources) {\n      if (source && typeof source === 'object') {\n        for (const [key, value] of Object.entries(source)) {\n          if (!(key in result)) {\n            result[key] = value;\n          }\n        }\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  // String methods\n  camelCase: function() {\n    const str = String(this._value);\n    const camelCased = str\n      .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())\n      .replace(/^./, chr => chr.toLowerCase());\n    return new this.constructor(camelCased);\n  },\n  \n  kebabCase: function() {\n    const str = String(this._value);\n    // Simpler approach: insert hyphen before any capital letter that follows a lowercase or digit\n    let result = str\n    .replace(/([a-z])([A-Z])/g, '$1-$2') // Add hyphen between lower/uppercase\n    .replace(/[\\s_]+/g, '-')             // Replace spaces/underscores with hyphen\n    .toLowerCase();\n      \n    return new this.constructor(result);\n  },\n  \n  snakeCase: function() {\n    const str = String(this._value);\n    const result = str && str\n    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n    .map(s => s.toLowerCase())\n    .join('_');\n      \n    return new this.constructor(result);\n  },\n  \n  startCase: function() {\n    const str = String(this._value);\n    const startCased = str\n      .replace(/([a-z])([A-Z])/g, '$1 $2')\n      .replace(/[_-]+/g, ' ')\n      .split(' ')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n    return new this.constructor(startCased);\n  },\n  \n  upperFirst: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toUpperCase() + str.slice(1));\n  },\n  \n  lowerFirst: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toLowerCase() + str.slice(1));\n  },\n  \n  capitalize: function() {\n    const str = String(this._value);\n    return new this.constructor(str.charAt(0).toUpperCase() + str.slice(1).toLowerCase());\n  },\n  \n  // Utility methods\n  size: function() {\n    if (Array.isArray(this._value) || typeof this._value === 'string') {\n      return this._value.length;\n    }\n    if (this._value && typeof this._value === 'object') {\n      return Object.keys(this._value).length;\n    }\n    return 0;\n  },\n  \n  isEmpty: function() {\n    if (this._value === null || this._value === undefined) return true;\n    if (Array.isArray(this._value)) return this._value.length === 0;\n    if (typeof this._value === 'string') return this._value.length === 0;\n    if (typeof this._value === 'object') return Object.keys(this._value).length === 0;\n    return false;\n  },\n  \n  includes: function(value, fromIndex) {\n    if (Array.isArray(this._value)) {\n      return this._value.includes(value, fromIndex);\n    }\n    if (typeof this._value === 'string' && typeof value === 'string') {\n      return this._value.includes(value, fromIndex);\n    }\n    if (this._value && typeof this._value === 'object') {\n      return Object.values(this._value).includes(value);\n    }\n    return false;\n  },\n  \n  // Function utilities\n  identity: function() {\n    return this._value;\n  },\n  \n  constant: function() {\n    const val = this._value;\n    return function() { return val; };\n  },\n  \n  times: function(iteratee) {\n    const n = Number(this._value) || 0;\n    const results = [];\n    for (let i = 0; i < n; i++) {\n      results.push(iteratee(i));\n    }\n    return new this.constructor(results);\n  },\n  \n  range: function(end, step) {\n    const start = Number(this._value) || 0;\n    const endNum = end !== undefined ? Number(end) : start;\n    const startNum = end !== undefined ? start : 0;\n    const stepNum = step || (startNum < endNum ? 1 : -1);\n    \n    const result = [];\n    if (stepNum > 0) {\n      for (let i = startNum; i < endNum; i += stepNum) {\n        result.push(i);\n      }\n    } else {\n      for (let i = startNum; i > endNum; i += stepNum) {\n        result.push(i);\n      }\n    }\n    return new this.constructor(result);\n  },\n  \n  clamp: function(lower, upper) {\n    const num = Number(this._value) || 0;\n    return Math.max(lower, Math.min(upper, num));\n  },\n  \n  random: function(upper, floating) {\n    const lower = Number(this._value) || 0;\n    const upperNum = upper !== undefined ? Number(upper) : 1;\n    \n    if (floating || lower % 1 || upperNum % 1) {\n      const rand = Math.random();\n      return lower + rand * (upperNum - lower);\n    }\n    return lower + Math.floor(Math.random() * (upperNum - lower + 1));\n  },\n  \n  // Chain\n  chain: function() {\n    // Return this for chaining\n    return this;\n  },\n  \n  value: function() {\n    // Also update public value property for VM unwrapping\n    this.value = this._value;\n    return this._value;\n  },\n  \n  valueOf: function() {\n    return this._value;\n  }\n};\n"},226:(t,e,n)=>{n.r(e),n.d(e,{ExpressionEvaluator:()=>_});var r=n(248),a=n.n(r);class i{static formatError(t,e){const n=[],r=i.getTypeLabel(t.type);return n.push(a().bold.red(`${r}: ${t.message}`)),t.detail&&n.push(a().gray(`DETAIL: ${t.detail}`)),t.position&&e&&(n.push(""),n.push(...i.formatErrorContext(e,t.position))),t.suggestion&&(n.push(""),n.push(a().yellow(`HINT: ${t.suggestion}`))),n.join("\n")}static getTypeLabel(t){switch(t){case"syntax":return"SYNTAX ERROR";case"security":return"SECURITY ERROR";case"runtime":return"RUNTIME ERROR"}}static formatErrorContext(t,e){const n=[],r=t.split("\n");let i=1,s=1,o=0;for(let n=0;n<t.length&&i<e.line;n++)"\n"===t[n]?(i++,s=1):s++,o++;for(let n=1;n<e.column&&o<t.length;n++)o++;const u=Math.max(0,e.line-2),l=Math.min(r.length,e.line+1);n.push(a().blue(`LINE ${e.line}:${e.column}`)),n.push("");for(let t=u;t<l;t++){const i=t+1,s=r[t],o=String(i).padStart(4," ");if(i===e.line){n.push(a().gray(`${o} | `)+a().white(s));const t=" ".repeat(6+e.column-1)+a().red("^".repeat(e.length||1));n.push(t)}else n.push(a().gray(`${o} | ${s}`))}return n}static parseJSONError(t,e){const n=t.message,r=n.match(/at position (\d+)/),a=n.match(/Unexpected token (.) in JSON at position (\d+)/),s=n.match(/Unexpected end of JSON input/);let o,u;if(r||a){const t=a?a[2]:r?.[1];if(t){const n=parseInt(t,10);if(o=i.calculatePosition(e,n),a){const t=a[1];t&&(u=i.getJSONSuggestion(t,e,n))}}}else s&&(o=i.calculatePosition(e,e.length),u="JSON input ended unexpectedly. Check for missing closing brackets or quotes.");return{type:"syntax",message:"Invalid JSON syntax",detail:n,position:o,suggestion:u}}static parseSecurityError(t,e){let n,r,a=null;for(const n of t){const t=e.indexOf(n);-1!==t&&(!a||t<a.index)&&(a={pattern:n,index:t})}return a&&(n=i.calculatePosition(e,a.index),n.length=a.pattern.length,r=i.getSecuritySuggestion(a.pattern)),{type:"security",message:"Expression contains potentially dangerous patterns",detail:`Found dangerous patterns: ${t.join(", ")}`,position:n,suggestion:r}}static parseExpressionError(t,e){const n=t.message,r=n.match(/Unexpected token '?(.+?)'?/);let a,s;if(n.match(/Missing (.+?) after/),r){const t=r[1];if(t){const n=e.indexOf(t);-1!==n&&(a=i.calculatePosition(e,n),a.length=t.length)}s=i.getExpressionSuggestion(n)}return{type:"syntax",message:"Invalid expression syntax",detail:n,position:a,suggestion:s}}static calculatePosition(t,e){let n=1,r=1;for(let a=0;a<Math.min(e,t.length);a++)"\n"===t[a]?(n++,r=1):r++;return{line:n,column:r}}static getJSONSuggestion(t,e,n){switch(t){case"'":return"Single quotes are not valid in JSON. Use double quotes instead.";case",":return n===e.length-1||"}"===e[n+1]||"]"===e[n+1]?"Trailing commas are not allowed in JSON.":"Check for missing values or extra commas.";case"}":case"]":return"Unexpected closing bracket. Check for matching opening brackets.";default:return"Check JSON syntax near this position."}}static getSecuritySuggestion(t){return{eval:"Use a safer alternative like JSON.parse() or a sandboxed evaluator.",Function:"Dynamic function creation is dangerous. Consider using predefined functions.",require:"Dynamic imports are not allowed. Use static imports or predefined modules.",import:"Dynamic imports are not allowed. Use static imports or predefined modules.",process:"Access to process object is restricted for security reasons.",global:"Access to global scope is restricted. Use the provided context.",__dirname:"File system access is not allowed in expressions.",__filename:"File system access is not allowed in expressions.","while(true)":"Infinite loops are not allowed. Use finite iterations.","for(;;)":"Infinite loops are not allowed. Use finite iterations.",readFile:"File system operations are not allowed in expressions.",writeFile:"File system operations are not allowed in expressions.",exec:"Shell command execution is not allowed for security reasons.",spawn:"Process spawning is not allowed for security reasons.",fetch:"Network requests are not allowed in expressions.",setTimeout:"Asynchronous operations are restricted. Use synchronous alternatives.",setInterval:"Asynchronous operations are restricted. Use synchronous alternatives.",Buffer:"Buffer operations are restricted for security reasons."}[t]||"This pattern is restricted for security reasons."}static getExpressionSuggestion(t){return t.includes("Unexpected token")?"Check for syntax errors like missing operators, brackets, or quotes.":t.includes("is not defined")?"The variable or function is not available in the expression context.":t.includes("Cannot read property")?"Trying to access a property of null or undefined. Add null checks.":"Review the expression syntax and ensure all variables are properly defined."}}const s=n(201).v.match(/globalThis\.lodashMethods = ({[\s\S]*});/);if(!s||!s[1])throw new Error("Failed to extract methods from LODASH_METHODS");const o=s[1],u=new Function(`return ${o}`)();class l{constructor(t){this._value=t,this.__isLodash=!0}get length(){return Array.isArray(this._value)||"string"==typeof this._value?this._value.length:this._value&&"object"==typeof this._value?Object.keys(this._value).length:0}[Symbol.iterator](){return null===this._value||void 0===this._value?[][Symbol.iterator]():Array.isArray(this._value)||"string"==typeof this._value?this._value[Symbol.iterator]():this._value&&"object"==typeof this._value?Object.entries(this._value)[Symbol.iterator]():[][Symbol.iterator]()}toJSON(){return this._value}valueOf(){return this._value}toString(){return null===this._value?"null":void 0===this._value?"undefined":String(this._value)}[Symbol.toPrimitive](t){return"string"===t?this.toString():this._value}}function c(...t){if(0!==t.length)return new l(t[0])}Object.entries(u).forEach(([t,e])=>{l.prototype[t]=function(...t){return e.apply(this,t)}}),Object.entries(u).forEach(([t,e])=>{c[t]=(...n)=>{if(n.length>0){const e=n[0],r=new l(e),a=r[t].call(r,...n.slice(1));return"chain"===t?a:a&&"object"==typeof a&&"__isLodash"in a&&!0===a.__isLodash?a._value:a}return e.call({_value:void 0,constructor:l})}});class h{constructor(t){this.context=this.createSecurityContext(t)}getSecurityContext(){return this.context}createEvaluationContext(t){const e={...t},{level:n}=this.context;if(n.allowedGlobals.length>0){const t={};for(const r of n.allowedGlobals)r in e&&(t[r]=e[r]);return t}return e}validateExpression(t){const e=[];let n;if(this.context.options.unsafe)return{valid:!0,errors:[]};if(this.shouldUseVM()){const r=[{pattern:/eval\s*\(/,name:"eval"},{pattern:/Function\s*\(/,name:"Function"},{pattern:/setTimeout/,name:"setTimeout"},{pattern:/setInterval/,name:"setInterval"},{pattern:/global\./,name:"global"},{pattern:/globalThis\./,name:"globalThis"},{pattern:/process\./,name:"process"},{pattern:/__dirname/,name:"__dirname"},{pattern:/__filename/,name:"__filename"},{pattern:/this\.constructor/,name:"this.constructor"},{pattern:/constructor\.constructor/,name:"constructor.constructor"},{pattern:/arguments\.callee/,name:"arguments.callee"},{pattern:/Buffer\./,name:"Buffer"},{pattern:/while\s*\(\s*true\s*\)/,name:"while(true)"},{pattern:/for\s*\(\s*;;\s*\)/,name:"for(;;)"},{pattern:/performance\.now/,name:"performance.now"},{pattern:/process\.hrtime/,name:"process.hrtime"},{pattern:/\[\s*['"`]constructor['"`]\s*\]/,name:'["constructor"]'},{pattern:/window\./,name:"window"},{pattern:/document\./,name:"document"},{pattern:/\[\s*['"`]eval['"`]\s*\]/,name:'["eval"]'},{pattern:/\(\s*\d+\s*,\s*eval\s*\)/,name:"(1, eval)"},{pattern:/\[\s*['"`]Function['"`]\s*\]/,name:'["Function"]'},{pattern:/require\s*\(/,name:"require"},{pattern:/import\s*\(/,name:"import"},{pattern:/execSync/,name:"execSync"},{pattern:/exec/,name:"exec"},{pattern:/spawn/,name:"spawn"},{pattern:/fork/,name:"fork"},{pattern:/readFile/,name:"readFile"},{pattern:/writeFile/,name:"writeFile"},{pattern:/readFileSync/,name:"readFileSync"},{pattern:/writeFileSync/,name:"writeFileSync"},{pattern:/createReadStream/,name:"createReadStream"},{pattern:/createWriteStream/,name:"createWriteStream"}],a=[];for(const{pattern:e,name:n}of r)e.test(t)&&a.push(n);if(a.length>0){e.push("Expression contains potentially dangerous patterns");const r=i.parseSecurityError(a,t);n=i.formatError(r,t)}}return{valid:0===e.length,errors:e,...void 0!==n&&{formattedError:n}}}shouldUseVM(){return this.context.level.useVM}getTimeout(){return this.context.level.timeout}getMemoryLimit(){return this.context.level.memoryLimit}getVMConfig(){return this.context.vmConfig}getCapabilities(){return this.context.capabilities}getWarnings(){return this.context.warnings}createSecurityContext(t){let e,n,r;return t.unsafe?e=this.createUnsafeLevel(t):(e=this.createSandboxLevel(t),n=this.createSandboxVMConfig(t),r=this.createSandboxCapabilities()),{level:e,options:t,warnings:[],...void 0!==n&&{vmConfig:n},...void 0!==r&&{capabilities:r}}}createSandboxLevel(t){return{allowNetwork:!1,allowShell:!1,allowFileSystem:!1,allowDynamicImports:!1,allowedGlobals:[],timeout:Number(t.cpuLimit)||3e4,memoryLimit:Number(t.memoryLimit)||128,...t.cpuLimit&&{cpuLimit:Number(t.cpuLimit)},maxContextSize:10485760,useVM:!0}}createUnsafeLevel(t){return{allowNetwork:!0,allowShell:!0,allowFileSystem:!0,allowDynamicImports:!0,allowedGlobals:[],useVM:!1}}createSandboxVMConfig(t){return{memoryLimit:Number(t.memoryLimit)||128,timeout:Number(t.cpuLimit)||3e4,...t.cpuLimit&&{cpuLimit:Number(t.cpuLimit)},enableAsync:!0,enableGenerators:!0,enableProxies:!1,enableSymbols:!0,maxContextSize:10485760,recycleIsolates:!0,isolatePoolSize:3}}createSandboxCapabilities(){return{console:!0,timers:!1,promises:!0,json:!0,math:!0,date:!0,array:!0,object:!0,string:!0,number:!0,boolean:!0,regexp:!0,error:!0,map:!0,set:!0,weakmap:!0,weakset:!0,proxy:!1,reflect:!0,symbol:!0,bigint:!0,intl:!1,buffer:!1,url:!1,crypto:!1}}}var f=n(593);class d{constructor(t){return this.data=t,new Proxy(this,{get(t,e,n){if(e in t){const r=Reflect.get(t,e,n);if("function"==typeof r){let n=d.methodCache.get(t);n||(n=new Map,d.methodCache.set(t,n));const a=String(e);let i=n.get(a);return!i&&r&&(i=r.bind(t)),i&&n.set(a,i),i}return r}return"string"==typeof e&&t.isObject(t.data)&&e in t.data?new d(t.data[e]):new d(void 0)}})}get value(){return this.data}get(t){return this.isObject(this.data)&&t in this.data?new d(this.data[t]):new d(void 0)}filter(t){return Array.isArray(this.data)?new d(this.data.filter(t)):new d([])}map(t){return Array.isArray(this.data)?new d(this.data.map(t)):new d([])}find(t){return Array.isArray(this.data)?new d(this.data.find(t)):new d(void 0)}where(t,e){if(Array.isArray(this.data)){const n=this.data.filter(n=>!(!this.isObject(n)||!(t in n))&&n[t]===e);return new d(n)}return new d([])}pluck(t){if(Array.isArray(this.data)){const e=this.data.map(e=>{if(this.isObject(e)&&t in e)return e[t]}).filter(t=>void 0!==t);return new d(e)}return new d([])}sortBy(t){if(Array.isArray(this.data)){const e=[...this.data].sort((e,n)=>{let r,a;if("function"==typeof t)r=t(e),a=t(n);else{if(!this.isObject(e)||!this.isObject(n))return 0;r=e[t],a=n[t]}return"string"==typeof r&&"string"==typeof a?r.localeCompare(a):"number"==typeof r&&"number"==typeof a?r-a:0});return new d(e)}return new d([])}take(t){return Array.isArray(this.data)?new d(this.data.slice(0,t)):new d([])}skip(t){return Array.isArray(this.data)?new d(this.data.slice(t)):new d([])}uniqBy(t){if(Array.isArray(this.data)){const e=new Set,n=this.data.filter(n=>{const r=t(n);return!e.has(r)&&(e.add(r),!0)});return new d(n)}return new d([])}flatten(){return Array.isArray(this.data)?new d(this.data.flat()):new d([])}flattenDeep(){if(Array.isArray(this.data)){const t=e=>e.reduce((e,n)=>Array.isArray(n)?e.concat(t(n)):e.concat(n),[]);return new d(t(this.data))}return new d([])}compact(){return Array.isArray(this.data)?new d(this.data.filter(Boolean)):new d([])}chunk(t){if(Array.isArray(this.data)){const e=[];for(let n=0;n<this.data.length;n+=t)e.push(this.data.slice(n,n+t));return new d(e)}return new d([])}takeWhile(t){if(Array.isArray(this.data)){const e=[];for(const n of this.data){if(!t(n))break;e.push(n)}return new d(e)}return new d([])}drop(t){return Array.isArray(this.data)?new d(this.data.slice(t)):new d([])}dropWhile(t){if(Array.isArray(this.data)){let e=0;for(;e<this.data.length&&t(this.data[e]);)e++;return new d(this.data.slice(e))}return new d([])}reverse(){return Array.isArray(this.data)?new d([...this.data].reverse()):new d(this.data)}shuffle(){if(Array.isArray(this.data)){const t=[...this.data];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return new d(t)}return new d(this.data)}sample(){if(Array.isArray(this.data)&&this.data.length>0){const t=Math.floor(Math.random()*this.data.length);return new d(this.data[t])}return new d(void 0)}sampleSize(t){if(Array.isArray(this.data)){const e=[...this.data].sort(()=>.5-Math.random());return new d(e.slice(0,t))}return new d([])}orderBy(t,e=[]){if(Array.isArray(this.data)){const n=[...this.data].sort(this.createOrderByComparator(t,e));return new d(n)}return new d([])}createOrderByComparator(t,e){return(n,r)=>{for(let a=0;a<t.length;a++){const i=t[a];if(!i)continue;const s=e[a]||"asc";let o,u;if("function"==typeof i)o=i(n),u=i(r);else{if(!this.isObject(n)||!this.isObject(r))continue;o=n[i],u=r[i]}let l=0;if(null!==o&&null!==u&&void 0!==o&&void 0!==u&&(o<u?l=-1:o>u&&(l=1)),0!==l)return"desc"===s?-l:l}return 0}}groupBy(t){if(Array.isArray(this.data)){const e={};for(const n of this.data){const r=t(n);e[r]||(e[r]=[]),e[r].push(n)}return new d(e)}return new d({})}countBy(t){if(Array.isArray(this.data)){const e={};for(const n of this.data){const r=t(n);e[r]=(e[r]||0)+1}return new d(e)}return new d({})}keyBy(t){if(Array.isArray(this.data)){const e={};for(const n of this.data)e[t(n)]=n;return new d(e)}return new d({})}pick(t){if(this.isObject(this.data)){const e=this.data,n={};for(const r of t)r in e&&(n[r]=e[r]);return new d(n)}return new d({})}omit(t){if(this.isObject(this.data)){const e={...this.data};for(const n of t)delete e[n];return new d(e)}return new d({})}invert(){if(this.isObject(this.data)){const t=this.data,e={};for(const[n,r]of Object.entries(t))e[String(r)]=n;return new d(e)}return new d({})}mean(){if(Array.isArray(this.data)){const t=this.data.filter(t=>"number"==typeof t);if(0===t.length)return new d(0);const e=t.reduce((t,e)=>t+e,0);return new d(e/t.length)}return new d(0)}min(){if(Array.isArray(this.data)){const t=this.data.filter(t=>"number"==typeof t);return new d(t.length>0?Math.min(...t):void 0)}return new d(void 0)}max(){if(Array.isArray(this.data)){const t=this.data.filter(t=>"number"==typeof t);return new d(t.length>0?Math.max(...t):void 0)}return new d(void 0)}minBy(t){if(Array.isArray(this.data)&&this.data.length>0){const e=this.data.reduce((e,n)=>t(n)<t(e)?n:e);return new d(e)}return new d(void 0)}maxBy(t){if(Array.isArray(this.data)&&this.data.length>0){const e=this.data.reduce((e,n)=>t(n)>t(e)?n:e);return new d(e)}return new d(void 0)}size(){return Array.isArray(this.data)?new d(this.data.length):this.isObject(this.data)?new d(Object.keys(this.data).length):new d(0)}isEmpty(){return null==this.data?new d(!0):Array.isArray(this.data)||"string"==typeof this.data?new d(0===this.data.length):this.isObject(this.data)?new d(0===Object.keys(this.data).length):new d(!1)}includes(t){return Array.isArray(this.data)?new d(this.data.includes(t)):this.isObject(this.data)?new d(Object.values(this.data).includes(t)):new d(!1)}length(){return Array.isArray(this.data)?new d(this.data.length):this.isObject(this.data)?new d(Object.keys(this.data).length):new d(0)}sum(t){if(Array.isArray(this.data)){const e=(t?this.data.map(e=>this.isObject(e)?e[t]:0):this.data).reduce((t,e)=>t+("number"==typeof e?e:0),0);return new d(e)}return new d(0)}keys(){return this.isObject(this.data)?new d(Object.keys(this.data)):new d([])}values(){return this.isObject(this.data)?new d(Object.values(this.data)):new d([])}entries(){return this.isObject(this.data)?new d(Object.entries(this.data)):new d([])}flatMap(t){if(Array.isArray(this.data)){const e=[];for(let n=0;n<this.data.length;n++){const r=t(this.data[n],n);Array.isArray(r)?e.push(...r):e.push(r)}return new d(e)}return new d([])}mapValues(t){if(this.isObject(this.data)){const e=this.data,n={};for(const[r,a]of Object.entries(e))n[r]=t(a,r);return new d(n)}return new d({})}isObject(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}valueOf(){return this.data}toString(){return JSON.stringify(this.data,null,2)}toJSON(){return this.data}[Symbol.toPrimitive](t){return"default"===t||"string"===t?this.data:"number"===t?"number"==typeof this.data?this.data:Number(this.data):this.data}partition(t){if(Array.isArray(this.data)){const e=[],n=[];for(let r=0;r<this.data.length;r++)t(this.data[r],r)?e.push(this.data[r]):n.push(this.data[r]);return new d([e,n])}return new d([[],[]])}windowed(t,e=1){if(Array.isArray(this.data)){if(t<=0)return new d([]);const n=[];for(let r=0;r<=this.data.length-t;r+=e)n.push(this.data.slice(r,r+t));return new d(n)}return new d([])}chunked(t){return this.chunk(t)}span(t){if(Array.isArray(this.data)){let e=this.data.length;for(let n=0;n<this.data.length;n++)if(!t(this.data[n],n)){e=n;break}const n=this.data.slice(0,e),r=this.data.slice(e);return new d([n,r])}return new d([[],[]])}takeUntil(t){if(Array.isArray(this.data)){const e=[];for(let n=0;n<this.data.length&&!t(this.data[n],n);n++)e.push(this.data[n]);return new d(e)}return new d([])}dropUntil(t){if(Array.isArray(this.data)){let e=0;for(;e<this.data.length&&!t(this.data[e],e);)e++;return new d(this.data.slice(e))}return new d([])}frequencies(){if(Array.isArray(this.data)){const t={};for(const e of this.data){const n=String(e);t[n]=(t[n]||0)+1}return new d(t)}return new d({})}groupWith(t,e){if(Array.isArray(this.data)){const n={};for(const r of this.data){const a=t(r),i=e(r);n[a]||(n[a]=[]),n[a].push(i)}return new d(n)}return new d({})}reduceBy(t,e,n){if(Array.isArray(this.data)){const r={};for(const a of this.data){const i=t(a);r[i]=r[i]?e(r[i],a):e(n,a)}return new d(r)}return new d({})}scanLeft(t,e){if(Array.isArray(this.data)){const n=[e];let r=e;for(let e=0;e<this.data.length;e++)r=t(r,this.data[e],e),n.push(r);return new d(n)}return new d([e])}distinctBy(t){if(Array.isArray(this.data)){const e=[],n=[];for(const r of this.data){const a=t(r);e.includes(a)||(e.push(a),n.push(r))}return new d(n)}return new d([])}intersectBy(t,e){if(Array.isArray(this.data)){const n=t.map(e),r=this.data.filter(t=>n.includes(e(t)));return new d(r)}return new d([])}spy(t){if(Array.isArray(this.data))for(let e=0;e<this.data.length;e++)t(this.data[e],e);return new d(this.data)}filterMap(t){if(Array.isArray(this.data)){const e=[];for(let n=0;n<this.data.length;n++){const r=t(this.data[n],n);null!=r&&e.push(r)}return new d(e)}return new d([])}findLast(t){if(Array.isArray(this.data))for(let e=this.data.length-1;e>=0;e--)if(t(this.data[e],e))return new d(this.data[e]);return new d(void 0)}quantify(t){if(Array.isArray(this.data)){let e=0;for(let n=0;n<this.data.length;n++)t(this.data[n],n)&&e++;return new d(e)}return new d(0)}pairwise(){if(Array.isArray(this.data)&&this.data.length>=2){const t=[];for(let e=0;e<this.data.length-1;e++)t.push([this.data[e],this.data[e+1]]);return new d(t)}return new d([])}intersperse(t){if(Array.isArray(this.data)){if(this.data.length<=1)return new d(this.data);const e=[this.data[0]];for(let n=1;n<this.data.length;n++)e.push(t,this.data[n]);return new d(e)}return new d([])}peekable(){if(Array.isArray(this.data)){const t=this.data;let e=0;return new d({hasNext:()=>e<t.length,next:()=>e<t.length?t[e++]:void 0,peek:()=>e<t.length?t[e]:void 0,remaining:()=>t.slice(e)})}return new d({hasNext:()=>!1,next:()=>{},peek:()=>{},remaining:()=>[]})}batched(t,e){if(Array.isArray(this.data)){if(t<=0)return new d([]);const n=[];for(let r=0;r<this.data.length;r+=t){const a=this.data.slice(r,r+t);if(void 0!==e&&a.length<t&&r+t>this.data.length)for(;a.length<t;)a.push(e);n.push(a)}return new d(n)}return new d([])}foldLeft(t,e){if(Array.isArray(this.data)){let n=t;for(let t=0;t<this.data.length;t++)n=e(n,this.data[t],t);return new d(n)}return new d(t)}foldRight(t,e){if(Array.isArray(this.data)){let n=t;for(let t=this.data.length-1;t>=0;t--)n=e(this.data[t],n,t);return new d(n)}return new d(t)}traverse(t,e){if(Array.isArray(this.data)){const n=[];let r=t;for(let t=0;t<this.data.length;t++){const{value:a,state:i}=e(r,this.data[t],t);n.push(a),r=i}return new d({values:n,finalState:r})}return new d({values:[],finalState:t})}delay(t){return new Promise(e=>{setTimeout(()=>e(new d(this.data)),t)})}debounceTime(t){return new Promise(e=>{if(!Array.isArray(this.data))return void setTimeout(()=>e(new d(this.data)),t);const n=this.data;0!==n.length?setTimeout(()=>{e(new d(n[n.length-1]))},t):e(new d([]))})}throttleTime(t){return new Promise(e=>{if(!Array.isArray(this.data))return void e(new d(this.data));const n=this.data;0!==n.length?setTimeout(()=>{e(new d(n[0]))},t):e(new d([]))})}timeout(t){return Promise.race([new Promise(t=>{t(new d(this.data))}),new Promise((e,n)=>{setTimeout(()=>n(new Error(`Operation timed out after ${t}ms`)),t)})])}async*interval(t){if(!Array.isArray(this.data))return void(yield new d(this.data));const e=this.data;for(const n of e)yield new d(n),await new Promise(e=>setTimeout(e,t))}async*timer(t,e){if(await new Promise(e=>setTimeout(e,t)),!Array.isArray(this.data))return void(yield new d(this.data));const n=this.data;let r=0;for(;r<n.length;)yield new d(n[r++]),e&&r<n.length&&await new Promise(t=>setTimeout(t,e))}async concatMap(t){if(!Array.isArray(this.data)){const e=await Promise.resolve(t(this.data,0));return new d(e)}const e=this.data,n=[];for(let r=0;r<e.length;r++){const a=await Promise.resolve(t(e[r],r));Array.isArray(a)?n.push(...a):n.push(a)}return new d(n)}async mergeMap(t){if(!Array.isArray(this.data)){const e=await Promise.resolve(t(this.data,0));return new d(e)}const e=this.data.map((e,n)=>Promise.resolve(t(e,n))),n=await Promise.all(e),r=[];for(const t of n)Array.isArray(t)?r.push(...t):r.push(t);return new d(r)}async switchMap(t){if(!Array.isArray(this.data)){const e=await Promise.resolve(t(this.data,0));return new d(e)}const e=this.data;if(0===e.length)return new d([]);const n=e[e.length-1],r=await Promise.resolve(t(n,e.length-1));return new d(Array.isArray(r)?r:[r])}async exhaustMap(t){if(!Array.isArray(this.data)){const e=await Promise.resolve(t(this.data,0));return new d(e)}const e=this.data;if(0===e.length)return new d([]);const n=e[0],r=await Promise.resolve(t(n,0));return new d(Array.isArray(r)?r:[r])}distinctUntilChanged(t){if(!Array.isArray(this.data))return new d(this.data);const e=this.data;if(0===e.length)return new d([]);const n=[e[0]];let r=t?t(e[0]):e[0];for(let a=1;a<e.length;a++){const i=t?t(e[a]):e[a];i!==r&&(n.push(e[a]),r=i)}return new d(n)}skipLast(t){if(!Array.isArray(this.data))return new d(t>0?void 0:this.data);const e=this.data;if(t<=0)return new d(e);const n=e.slice(0,Math.max(0,e.length-t));return new d(n)}takeLast(t){if(!Array.isArray(this.data))return new d(t>0?this.data:void 0);const e=this.data;if(t<=0)return new d([]);const n=e.slice(Math.max(0,e.length-t));return new d(n)}combineLatest(t){if(!Array.isArray(this.data))return new d([this.data,...t.map(t=>t[t.length-1]||null)]);const e=this.data,n=Math.max(e.length,...t.map(t=>t.length)),r=[];for(let a=0;a<n;a++){const n=[a<e.length?e[a]:e[e.length-1]||null];for(const e of t)n.push(a<e.length?e[a]:e[e.length-1]||null);r.push(n)}return new d(r)}zip(t){if(!Array.isArray(this.data))return new d([this.data,...t.map(t=>t[0]||null)]);const e=this.data,n=Math.min(e.length,...t.map(t=>t.length)),r=[];for(let a=0;a<n;a++){const n=[e[a]];for(const e of t)n.push(e[a]);r.push(n)}return new d(r)}merge(t){if(!Array.isArray(this.data)){const e=[this.data];for(const n of t)e.push(...n);return new d(e)}const e=[...this.data];for(const n of t)e.push(...n);return new d(e)}async retry(t,e){let n=0;const r=t+1;for(;n<r;)try{if(e){const t=await e();return new d(t)}return new d(this.data)}catch(t){if(n++,n>=r)throw t;await new Promise(t=>setTimeout(t,1e3*2**(n-1)))}return new d(this.data)}async catchError(t){try{return new d(this.data)}catch(e){const n=await Promise.resolve(t(e));return new d(n)}}forEach(t){if(Array.isArray(this.data)){const e=this.data;e.forEach((n,r)=>{t(n,r,e)})}else t(this.data,0,[this.data]);return new d(this.data)}each(t){return this.forEach(t)}async forEachAsync(t){return Array.isArray(this.data)?await(async(t,e)=>{await Promise.all(t.map((n,r)=>e(n,r,t)))})(this.data,t):await t(this.data,0,[this.data]),new d(this.data)}async forEachAsyncSeq(t){return Array.isArray(this.data)?await(async(t,e)=>{for(let n=0;n<t.length;n++)await e(t[n],n,t)})(this.data,t):await t(this.data,0,[this.data]),new d(this.data)}async mapAsync(t){if(Array.isArray(this.data)){const e=await(async(t,e)=>Promise.all(t.map((n,r)=>e(n,r,t))))(this.data,t);return new d(e)}const e=await t(this.data,0);return new d([e])}async mapAsyncSeq(t){if(Array.isArray(this.data)){const e=await(async(t,e)=>{const n=[];for(let r=0;r<t.length;r++)n.push(await e(t[r],r,t));return n})(this.data,t);return new d(e)}const e=await t(this.data,0);return new d([e])}tap(t){return Array.isArray(this.data)?this.data.forEach((e,n)=>{t(e,n)}):t(this.data,0),new d(this.data)}startWith(t){return Array.isArray(this.data)?new d([t,...this.data]):new d([t,this.data])}[Symbol.iterator](){return Array.isArray(this.data)?this.data[Symbol.iterator]():[][Symbol.iterator]()}}d.methodCache=new WeakMap;const p=["map","filter","find","reduce","groupBy","sortBy","orderBy","slice","flatten","flattenDeep","flatMap","uniq","uniqBy","compact","chunk","pluck","where","findWhere","first","last","take","takeWhile","drop","dropWhile","skip","sample","sampleSize","shuffle","reverse","keys","values","entries","pick","omit","invert","defaults","merge","extend","mapValues","clone","has","includes","get","set","sum","mean","min","minBy","max","maxBy","count","countBy","keyBy","size","isEmpty","isArray","isObject","isString","isNumber","toArray","partition","windowed","chunked","span","takeUntil","dropUntil","frequencies","groupWith","reduceBy","scanLeft","distinctBy","intersectBy","spy","filterMap","findLast","quantify","pairwise","intersperse","peekable","batched","foldLeft","foldRight","traverse","delay","debounceTime","throttleTime","timeout","interval","timer","concatMap","mergeMap","switchMap","exhaustMap","distinctUntilChanged","skipLast","takeLast","combineLatest","zip","merge","retry","catchError","tap","startWith","forEach","each","forEachAsync","forEachAsyncSeq","mapAsync","mapAsyncSeq"];function y(t){if(null==t){const e=(...e)=>0===e.length?t:new d(e[0]);return Object.defineProperty(e,"valueOf",{value:()=>t}),Object.defineProperty(e,"toString",{value:()=>String(t)}),Object.defineProperty(e,"toJSON",{value:()=>t}),Object.defineProperty(e,Symbol.toPrimitive,{value:e=>"default"===e||"string"===e?t:"number"===e?"number"==typeof t?t:Number(t):t}),e}if(Array.isArray(t)){const e=[...t];return Object.defineProperty(e,"data",{value:t,enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(e,"value",{value:t,enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(e,"constructor",{value:Array,enumerable:!1,configurable:!0,writable:!0}),m(e,t),Object.defineProperty(e,"chain",{value:()=>new d(t),enumerable:!1,configurable:!0,writable:!1}),Object.defineProperty(e,"toJSON",{value:()=>t,enumerable:!1,configurable:!0}),Object.defineProperty(e,"valueOf",{value:()=>t,enumerable:!1,configurable:!0}),Object.defineProperty(e,"toString",{value:()=>JSON.stringify(t),enumerable:!1,configurable:!0}),e}const e=(...e)=>0===e.length?new d(t):new d(e[0]);if("object"==typeof t&&!Array.isArray(t)){const n=t;for(const[t,r]of Object.entries(n))p.includes(t)||Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!1});return new Proxy(e,{get(t,e,r){if("hasOwnProperty"===e)return t=>Object.hasOwn(n,t);if("propertyIsEnumerable"===e)return t=>Object.prototype.propertyIsEnumerable.call(n,t);if("toJSON"===e)return()=>n;if("valueOf"===e)return()=>n;if("toString"===e)return()=>JSON.stringify(n);if("string"==typeof e&&Object.hasOwn(n,e)){const t=n[e];return p.includes(e),new d(t)}const a=Reflect.get(t,e,r);return void 0!==a?a:void 0},getOwnPropertyDescriptor:(t,e)=>"string"==typeof e&&e in n?{configurable:!0,enumerable:!0,value:n[e],writable:!1}:Reflect.getOwnPropertyDescriptor(t,e),has:(t,e)=>e in n||Reflect.has(t,e),ownKeys:()=>Object.keys(n)})}return Object.defineProperty(e,"hasOwnProperty",{value:Object.prototype.hasOwnProperty,enumerable:!1,configurable:!0}),Object.defineProperty(e,"propertyIsEnumerable",{value:Object.prototype.propertyIsEnumerable,enumerable:!1,configurable:!0}),m(e,t),Object.defineProperty(e,"toJSON",{value:()=>t,enumerable:!1,configurable:!0}),Object.defineProperty(e,"valueOf",{value:()=>t,enumerable:!1,configurable:!0}),Object.defineProperty(e,"toString",{value:()=>"string"==typeof t?t:"number"==typeof t||"boolean"==typeof t?String(t):JSON.stringify(t),enumerable:!1,configurable:!0}),Object.defineProperty(e,Symbol.for("nodejs.util.inspect.custom"),{value:()=>t,enumerable:!1,configurable:!0}),e}function m(t,e){const n=new d(e);for(const r of p)if(r in n&&"function"==typeof n[r]){if("object"==typeof e&&!Array.isArray(e)&&null!==e&&r in e)continue;Object.defineProperty(t,r,{value:(...t)=>{const a=n[r];if("function"!=typeof a)throw new Error(`${r} is not a function`);const i=a(...t);if(Array.isArray(e))return i;if(i&&"object"==typeof i&&"value"in i){const t=i.value;return Array.isArray(t)?y(t):t}return i},enumerable:!1,configurable:!0,writable:!1})}Object.defineProperty(t,"chain",{value:()=>new d(e),enumerable:!1,configurable:!0,writable:!1})}let w,g,v,b=!1;async function A(){if(!b){try{const t=await Promise.all([n.e(867),n.e(367)]).then(n.bind(n,367));w=t.VMSandboxSimple}catch(t){console.error("Failed to load vm-sandbox-simple module:",t)}try{const t=await Promise.all([n.e(867),n.e(833)]).then(n.bind(n,833));g=t.VMSandboxQuickJS}catch(t){console.error("Failed to load vm-sandbox-quickjs module:",t)}try{const t=await n.e(867).then(n.bind(n,867));v=t.getVMEngineType}catch(t){console.error("Failed to load VMEngineFactory module:",t)}b=!0}}class _{constructor(t,e){this.vmSandbox=null,this.options=t,this.appContext=e,this.securityManager=new h(t),t.safe&&!_.warningShown&&(console.warn("⚠️  Warning: --safe mode has been deprecated. All evaluations now run in optimized mode."),_.warningShown=!0)}async dispose(){this.vmSandbox&&(await this.vmSandbox.dispose(),this.vmSandbox=null)}showSecurityWarnings(){const t=this.securityManager.getWarnings();for(const e of t)console.error(e)}async evaluate(t,e){await A();try{this.showSecurityWarnings();const n=this.transformExpression(t),r=this.securityManager.validateExpression(n);if(!r.valid){if(r.formattedError)throw new Error(r.formattedError);throw new Error(`Security validation failed: ${r.errors.join(", ")}`)}if("$"===n.trim()&&null==e)return e;if("_"===n.trim()&&!this.securityManager.shouldUseVM())return(await this.loadUtilities())(e);const a=this.securityManager.shouldUseVM()?e:y(e),i=await this.createEvaluationContext(a,e),s=this.securityManager.createEvaluationContext(i),o=await this.executeExpression(n,s);return this.unwrapResult(o)}catch(t){if(t instanceof Error&&t.message.includes("Security validation failed"))throw t;throw new Error(`Expression evaluation failed: ${t instanceof Error?t.message:"Unknown error"}`)}}transformExpression(t){const e=(0,f.transformExpression)(t,this.appContext?.expressionCache);return this.options.verbose&&e!==t&&console.error("Transformed expression:",e),e}async createEvaluationContext(t,e){return this.securityManager.shouldUseVM()?{data:e,$:t,_:null}:{$:t,console:this.createConsoleObject(),JSON,Math,Date,Array,Object,String,Number,Boolean,Set,Map,Reflect,Symbol,_:await this.loadUtilities(),data:e}}createConsoleObject(){return{log:console.log,error:console.error,warn:console.warn,info:console.info,debug:this.options.verbose?console.debug:()=>{},trace:this.options.verbose?console.trace:()=>{},table:console.table,time:console.time,timeEnd:console.timeEnd,group:console.group,groupEnd:console.groupEnd,clear:console.clear,count:console.count,assert:console.assert,dir:console.dir}}async executeExpression(t,e){return this.securityManager.shouldUseVM()?(this.options.verbose&&console.error("🔒 Running in secure VM isolation mode"),await this.executeInVMSandbox(t,e)):(this.options.verbose&&console.error("⚡ Running in non-VM mode (should not happen)"),await this.safeEval(t,e))}async unwrapResult(t){if(this.debugResult(t),t instanceof Promise){const e=await t;return this.unwrapResult(e)}return this.isAsyncGenerator(t)?this.handleAsyncGenerator(t):this.isChainableWrapper(t)?this.unwrapChainableWrapper(t):this.isSmartDollar(t)?this.unwrapSmartDollar(t):t}debugResult(t){this.options.verbose&&(console.error("Debug: Result type:",typeof t,"isArray:",Array.isArray(t)),t&&"object"==typeof t&&(console.error("Debug: Result has value:","value"in t),console.error("Debug: Result constructor:",t.constructor?.name)))}isChainableWrapper(t){return null!==t&&"object"==typeof t&&!Array.isArray(t)&&"value"in t&&(t.constructor.name.includes("ChainableWrapper")||t.constructor.name.includes("_ChainableWrapper"))}isAsyncGenerator(t){return null!==t&&"object"==typeof t&&"next"in t&&"function"==typeof t.next&&Symbol.asyncIterator in t&&"function"==typeof t[Symbol.asyncIterator]}async handleAsyncGenerator(t){const e=[];for await(const n of t){const t=this.isChainableWrapper(n)?this.unwrapChainableWrapper(n):n;e.push(t)}return e}unwrapChainableWrapper(t){this.options.verbose&&console.error("Debug: Unwrapping result with .value");const e=t.value;return this.options.verbose&&console.error("Debug: Unwrapped value type:",typeof e),e}isSmartDollar(t){return null!==t&&"object"==typeof t&&"__isSmartDollar"in t&&!0===t.__isSmartDollar}unwrapSmartDollar(t){this.options.verbose&&console.error("Debug: Unwrapping SmartDollar object");const e=t,n=void 0!==e._value?e._value:e.value;return this.options.verbose&&console.error("Debug: Unwrapped SmartDollar value type:",typeof n),n}async safeEval(t,e){const n=Object.keys(e),r=Object.values(e);try{const e=new(0,Object.getPrototypeOf(async()=>{}).constructor)(...n,`\n        "use strict";\n        return (${t});\n      `);return await e(...r)}catch(e){if(e instanceof Error){const n=i.parseExpressionError(e,t),r=i.formatError(n,t);throw new Error(r)}throw new Error("Invalid expression: Syntax error")}}async loadUtilities(){return c}async executeInVMSandbox(t,e){if(await A(),!this.vmSandbox){const t=this.securityManager.getVMConfig();if(!t)throw new Error("VM configuration not available");if("quickjs"===(v?v():"quickjs")&&g)this.vmSandbox=new g(this.appContext,t),this.options.verbose&&console.error("Using QuickJS VM engine (on-demand)");else{if(!w)throw new Error("No VM sandbox available");this.vmSandbox=new w(this.appContext,t),this.options.verbose&&console.error("Using VM engine (on-demand)")}}try{const n=this.securityManager.getTimeout(),r=this.securityManager.getMemoryLimit(),a={...void 0!==n&&{timeout:n},...void 0!==r&&{memoryLimit:r},allowedGlobals:this.securityManager.getSecurityContext().level.allowedGlobals,allowNetwork:this.securityManager.getSecurityContext().level.allowNetwork};if(this.options.verbose){console.error("VM Context keys:",Object.keys(e));for(const[t,n]of Object.entries(e))console.error(`  ${t}: ${typeof n}${"function"==typeof n?` (${n.name||"anonymous"})`:""}`)}const i={};for(const[t,n]of Object.entries(e))i[t]=n;return(await this.vmSandbox.execute(t,i,a)).value}catch(e){if(e instanceof Error){if(this.options.verbose&&(console.error("VM execution error:",e.message),console.error("Expression:",t),console.error("Stack:",e.stack)),e.message.includes("Cannot find module"))throw new Error("VM module not found. Please ensure all dependencies are properly installed.");const n=i.parseExpressionError(e,t);if(e.message.includes("QuickJS initialization failed"))throw e;n.type="runtime",n.message="VM execution failed",n.detail=e.message;const r=i.formatError(n,t);throw new Error(r)}throw e}}}_.warningShown=!1}}]);